---
title: "✍ 200729_TIL"
categories: TIL
tags: [ TIL ]
toc: true
---

# 오늘 공부한 내용

## 강의노트
비트캠프 엄진영 강사님의 수업을 들으며 정리하였습니다.



### 논리연산자 && vs &, || vs |

**@&& vs &**

```java
boolean a = false;
boolean b = false;

// &&
boolean r = a && (b = true);
System.out.println("a=%b, b=%b, r=%b\n", a, b, r);
// a=false, b=false, r=false

// &
r = a & (b = true);
System.out.printf("a=%b, b=%b, r=%b\n", a, b, r);
// a=false, b=true, r=false
```

**@|| vs |**

```java
boolean a = true;
boolean b = false;

// ||
boolean r = a || (b = true);
System.out.printf(a=%b, b=%b, r=%b, a, b, r);
// a=true, b=false, r=true;

// |
r = a | (b = true);
System.out.printf(a=%b, b=%b, r=%b, a, b, r);
// a=true, b=true, r=true;
```

&&, ||의 경우 앞의 피연산자의 값으로 결과를 알 수 있다면 뒤의 명령은 실행하지 않는다. 위의 코드에서 a의 값만 보고도 결과가 판단이 되기 때문에 (b = true) 할당 명령을 실행하지 않았다. 반면, &. |경우 앞의 피연산자로 결과를 알 수 있을 지라도, 뒤에 놓은 경령까지 모두 실행한다.



### 비트 연산자

#### 비트 연산자의 활용

비트연산은 마스킹, 오버레이 기법, 색조 변경 등 이미지 및 영상 처리에 사용된다. 비트 단위 연산을 사용하면 연산의 가장 작은 단위인 비트 수준에서 연산을 수행하기 때문에 정보를 효율적으로 저장할 수 있기 때문이다. 

```
<노란색 강화>
   10001100 10010010 10101100	(변경전 색)
|  10010010 01001001 00000000	(빨강, 초록빛 강화)
-------------------------------
   10011110 11011011 10101100	(결과값)
   
<노란색 약화>
   10001100 10010010 10101100   (변경전 색)
 & 11111011 11111101 11111111   (빨강, 초록빛 약화)
-------------------------------
   10001000 10010000 10101100 (변견한 색)
```

색을 표현하기 위해 컴퓨터는 RGB 각 색상을 8비트로 표현한다. 이때 |와 & 연산을 활용하면 각 색에 대한 비트를 통과시키거나, 빼거나, 더하여 색감을 조절할 수 있다. 위의 첫번째 비트 연산은 기존 이미지의 노란색을 강화하여 빈티지한 느낌을 주는 필터 역할을 하고 있다. 비트연산으로 색을 다루는 것을 코드로 구현해보자.

```java
// 빨간색 제거
int pixel = 0x003f448;
System.out.println(pixel & 0x0000ffff);

// 파란색 강화
```



#### 비트 연산자 &와 %



### 비트 이동 연산자





### 증감 연산자



### 할당 연산자







# 느낀 점

