---
title: "✍ 200725_TIL"
categories: TIL
tags: [ TIL ]
toc: true
---

# 오늘 공부한 내용

## 강의노트
비트캠프 엄진영 강사님의 수업을 들으며 정리하였습니다.



### 배열

#### c언어에서 배열 사용하기

##### c언어의 규칙 

데이터타입에 따라 메모리가 정해져 있는 Java와 달리, c언어에서는 메모리는 운영체제에 따라 달라진다. 16비트 운영체제에서 int는 16비트, 32비트 운영체제에서는 32비트이다. 이때 CPU가 몇 비트인지는 중요하지 않다. Java는 운영체제에 상관 없이 무조건 4바이트이다.

##### 리눅스에서 c언어 소스코드 컴파일하기

gcc -o hello hello.c 

- `gcc`: gnu 오픈소스 프로젝트의 패키지
- `-o hello`: hello이름으로 컴파일하기
- `hello.c`: 컴파일할 소스코드

##### 주소를 담는 변수 사용하기: 배열X

```c
#include <stdio.h>
#include <stdlib.h>
// 레퍼런스
int main() {
  int i1, i2, i3;
  i1 = 100;
  i2 = 200;
  i3 = 300;
  
  // 주소를 담는 변수 = 포인터(pointer)
  int* p;
  
  //i1에 들어있는 값이 아니라 i1 메모리의 주소를 이 자리에 넣어라.
  p = &i1;
  //p에 들어있는 주소로 찾아가서 그 메모리의 값을 출력하라.
  printf("%d(%x) --> %d\n", p, p, *p);	//-1290692204(b3119994) --> 100
  
  p= &i2;
  printf("%d(%x) --> %d\n", p, p, *p);	//852309736(32cd36e8) --> 200
  
  p = &i3;
  printf("%d(%x) --> %d\n", p, p, *p);	//-1382156852(ad9df5cc) --> 300
  
  *p = 500;
  printf("%d\n", i3);					//500
  
  return 0;
}
```

여기서 변수 p는 주소를 담는 변수로, C언어에서는 이를 **포인터(pointer)**라 부른다. 여기서 메모리 주소는 메모리의 첫번째 바이트의 주소이다. C언어에서는 자바와 달리 직접 주소값을 조회할 수 있고 수정할 수도 있어 자바의 레퍼런스(reference)(포인터와 같은 개념) 개념을 이해하기 좋다. 



##### 주소를 담는 변수 사용하기: 배열O

```java
  int i[3];
  i[0] = 100;
  i[1] = 200;
  i[2] = 300;
  
  printf("%d, %d, %d\n", i[0], i[1], i[2]);

  p = &i[0];
  printf("%d\n", p, *p);	//-290063748, 100

  p = &i[1];
  printf("%d\n", p, *p);	//-290063752, 200

  p = &i[2];
  printf("%d\n", p, *p)		//-290063756, 300
```

주소값을 출력해보면 각각의 인덱스는 int의 단위인 4바이트로 나누어진다. 배열은 **연속된 메모리**라는 것을 알 수 있다. 



#### 배열

##### 배열이란?

같은 종류의 메모리를 쉽게 만드는 방법

##### 문법: 배열 레퍼런스를 선언하는 방법 

```java
int[] arr = new int[5];	
// 메모리종류[] 메모리이름 = new 메모리종류[개수]
// 데이터타입[] 변수명    = new 데이터타입[개수]

//c언어 스타일 
int arr[] = new int[5];	//단 개수를 지정해서는 안 된다.
```



### Java 배열과 레퍼런스

![instance-reference-initialize](https://user-images.githubusercontent.com/50407047/88539131-a3f3a600-d04b-11ea-836e-fbc90deebb71.jpg)

#### 인스턴스(instance)
인스턴스: new 명령으로 확보한 메모리


#### 레퍼런스(reference)

```java
int[] p = new int[3];
```

여기서 p는 int 배열의 주소를 담는 변수이다. 자바에서는 주소를 담는 변수를 '레퍼런스'라 부른다. `new int[3]`는 int 변수를 연속해서 3개 확보하라는 명령이다. 메모리를 확보한 후 리턴 값은 그 메모리의 시작 주소이다.



#### 배열에 값 저장

```java
p[0] = 100;
p[1] = 200;
p[2] = 300;

System.out.printf("%d, %d, %d", p[0], p[1], p[2]);
```



#### 배열 범위를 넘어가는 값을 저장할 경우 

```java
p[3] = 400;
```

인덱스의 범위를 넘어가면 **실행 예외(runtime exception)**가 발생한다. 사용할 수 없는 메모리에 값을 넣어도 그냥 실행하는 c언어와의 차이점이다. 



#### 배열의 개수 알아내기

`arrayName.length`사용

```java
System.out.println(p.length);
```
단, 다음과 같이 **배열의 주소가 없는 상태에서 사용하지 말아야 한다**. c언어의 경우 컴파일 가능하지만 java의 경우 컴파일 오류가 발생한다.
```java
int[] x;
System.out.println(x.length);
```



#### 배열을 사용하면 반복문을 사용하기 좋음

```java
int sum = 0;
for (int i = 0; i < p.length; i++) {
  sum = sum + p[i];
}
System.out.println(sum);
```

#### 레퍼런스 변수의 주소 값을 0으로 초기화하기

```java
// 레퍼런스 변수의 주소 값을 0으로 초기화하기
//p2 = 0;   // 컴파일 오류! 이렇게 직접적으로 초기화시킬 수 없다.
p2 = null;  // 주소 변수(레퍼런스)를 0으로 초기화시키려면 null을 사용하라.
```



#### 가비지(garbage)

![garbage-garbageCollector](https://user-images.githubusercontent.com/50407047/88539193-c4bbfb80-d04b-11ea-92e6-059c63641c3b.jpg)

```c
int* x1;

x1 = (int*) malloc(12);
x1 = (int*) malloc(120); // 예( 200번지, 100번지는 가비지가 된다.
// 100번지는 주소를 잃어 버려 사용할 수 없다.
// 존재를 하지만 주소를 이용하여 쓸 수 없음. 메모리만 차지.
// dangling object(c언어) = garbage(자바)


free(x1);	//메모리 해제. 200번지 주소는 무효하다.

x1[0] = 34;	//x1은 무효한 주소를 갖고 있다.
// 무효한 주소를 dangling pointer 라 부른다.
// x1은 해제된 메모리를 가리킴. 쓰지 않겠다고 선언한 무효한 주소를 dangling pointer. 자바의 경우 이것이 존재할 수 없음. 메모리를 강제로 해제시키는 명령어가 없기 때문. c++의 경우에는 delete이라는 명령어로 해제. 
```



#### 가비지 컬렉터



`System.gc();`

- 당장 가비지 컬렉터를 실행하라는 뜻이 아니라 가능하다면 빠른 시일 내에 가비지를 수집해 줄 것을 요구!
- `gc()`를 호출한다고 해서 바로 가비지 컬렉터가 동작하는 것은 아니다.
- 그 요구를 수용할 지 여부는 JVM의 판단에 달려 있다.
- 따라서 gc()를 호출하면 가비지 컬렉터가 바로 실행된다고 믿지 말라!
- 직접 호출할 생각 하지 마라







### 코틀린

자바 호환 언어 

안드로이드 개발에는 자바보다 코틀린 (구글이 자바로 만들어진 코드를 코틀린으로 변경하고 있음)

null Point exception 문제 해결하기 위해 만든 언어

https://codechacha.com/ko/kotlin-null-safety/








# 느낀 점
