---
<<<<<<< HEAD
title: "✍ 200724_TIL"
=======
title: "✍ 200723_TIL"
>>>>>>> 77868c5932abd9689afafdd1b0eb650fe6d46df6
categories: TIL
tags: [ TIL ]
toc: true
---

# 오늘 공부한 내용

## 강의노트
비트캠프 엄진영 강사님의 수업을 들으며 정리하였습니다.

<<<<<<< HEAD
### [자바 문법 몸소 체험하기](https://github.com/hayeon17kim/bitcamp-workspace/tree/master/bitcamp-java-project-04)

#### 1. 낱개의 변수를 사용하여 여러 회원 정보 처리하기
[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_a.java)

##### 배열의 중요성
```java
int no1, no2, no3, no4, no5;
String name1, name2, name3, name4, name5;
String email1, email2, email3, email4, email5;
String password1, password2, password3, password4, password5;
String photo1, photo2, photo3, photo4, photo5;
String tel1, tel2, tel3, tel4, tel5;
java.sql.Date now1, now2, now3, now4, now5;
long currentMillis;
```
혼돈 그 자체의 변수 선언.. 배열이 필요한 이유

##### 클래스의 패키지 정보 선언하기
```java
import java.util.Scanner;
```
위와 같이 클래스의 패키지 정보를 미리 선언하여 컴파일러에게 알려줄 수 있다. 위의 코드에서 Scanner가 java.util에 있는 Scanner라는 것을 먼저 알려주면 Scanner를 사용할 때 일일이 명시하지 않아도 된다!

```java
//import를 하지 않았을 때
java.util.Scanner keyInput = new java.util.Scanner(System.in);
//import를 해줬을 때
Scanner keyInput = new Scanner(System.in)
```

#### 2. 조건문을 사용하여 입출력 제어하기

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_b.java)

조건문을 사용하지 않은 1번에서는 정해진 인원(5명)만큼만 데이터를 입력받을 수 있었다. 조건문을 사용하여 필요한 만큼만 입력 받고 출력할 수 있게 되었다.


#### 3. 배열을 사용하여 여러 개의 값을 다루기
배열을 사용하면 간단하게 여러 개의 변수를 선언할 수 있다.

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_c.java)

1번과 2번에서는 배열을 사용하지 않고 필요한 값 만큼 변수를 생성해주었다. 
그러나 이렇게 되면 100명의 데이터값을 입력받을 경우 무려 700개의 변수를 생성해줘야 한다...!! 
배열을 사용해보자.


```java
// 반복문을 사용하지 않았을 때
int no1 = 0, no2 = 0, no3 = 0, no4 = 0, no5 = 0;
String name1 = "", name2 = "", name3 = "", name4 = "", name5 = "";
String email1 = "", email2 = "", email3 = "", email4 = "", email5 = "";
String password1 = "", password2 = "", password3 = "", password4 = "", password5 = "";
String photo1 = "", photo2 = "", photo3 = "", photo4 = "", photo5 = "";
String tel1 = "", tel2 = "", tel3 = "", tel4 = "", tel5 = "";
java.sql.Date now1 = null, now2 = null, now3 = null, now4 = null, now5 = null;
```
으악!!!


```java
// 배열을 사용했을 때
int[] no = new int[5];
String[] name = new String[5];
String[] email = new String[5];
String[] password = new String[5];
String[] photo = new String[5];
String[] tel = new String[5];
Date[] now = new Date[5];

```


#### 4. 반복문을 사용하여 여러 개의 값을 다루기
반복문을 사용하면 같은 코드를 중복해서 작성할 필요가 없다.

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_d.java)
```java
// 반복문을 사용하지 않았을 때
System.out.printf("%d, %s, %s, %s, %s\n", no[0], name[0], email[0], tel[0], now[0].toString());
    if(count > 1) {
      System.out.printf("%d, %s, %s, %s, %s\n", no[1], name[1], email[1], tel[1], now[1].toString());
      if(count > 2) {
        System.out.printf("%d, %s, %s, %s, %s\n", no[2], name[2], email[2], tel[2], now[2].toString());
        if(count > 3) {
          System.out.printf("%d, %s, %s, %s, %s\n", no[3], name[3], email[3], tel[3], now[3].toString());
          if(count > 4) {
            System.out.printf("%d, %s, %s, %s, %s\n", no[4], name[4], email[4], tel[4], now[4].toString());
          }
        }
      }
    } 

// 반복문을 사용했을 때
```java
for (int i = 0; i < count; i++) {
    System.out.printf("%d, %s, %s, %s, %s\n", 
        no[i], name[i], email[i], tel[i], now[i].toString());
}
```


# 느낀 점
=======
### 읽을 책 목록

- 코딩 인터뷰 완전 정복
- 코딩 알고리즘
- The art of computer programming (도널드 커누스:)
- concrete mathematics(컴퓨터과학의 기초를 다지는 단단한 수학)
- Algorithms (개정 4판): Robert Sedgewick
- 그림으로 배우는 알고리즘
-  Pro Git (pdf는 무료)
- 배시 핵심 레퍼런스
- 리눅스 커맨드라인 완벽 입문서 

### 자바 개요
![java-overview](https://user-images.githubusercontent.com/50407047/88278240-06336a80-cd1d-11ea-87c7-97a3ba89a01a.jpg)

1일 1 알고리즘 문제를 풀어야 한다. 책을 사서 매일매일 공부하자! 메소드까지만 배워도 알고리즘 문제를 풀 준비가 된 것이다.

### 자바 변수
![variable1](https://user-images.githubusercontent.com/50407047/88278239-059ad400-cd1d-11ea-8f7a-1470e6016ec1.jpg)
**변수**란 값을 저장하는 메모리를 의미하고 **변수 선언**이란 값을 저장하는 메모리를 준비하는 명령어이다. 변수 선언은 값을 저장할 메모리의 위치와 크기를 결정하고 그 메모리에 이름을 부여하는 과정이다. 변수를 선언한 후 그 이름을 사용해서 메모리에 접근하고, 값을 넣고, 꺼낸다. *변수를 생성한다*라고 표현하기도 한다.  

#### 변수 선언
![variable2](https://user-images.githubusercontent.com/50407047/88278238-059ad400-cd1d-11ea-81ec-225a53c5df85.jpg)
여기서 파란색 부분이 Java Virtual Machine이 OS로부터 사용을 허락받은 메모리이다. 해당 메모리는 명령어를 저장하는 **Code Segment**, 명령어를 실행하는 데 사용할 데이터를 저장하는 **Data Segment**로 이루어진다. 변수 선언은 메모리를 확보하는 명령어이고, 이로 인해 확보된 메모리를 변수라고 한다.


```java
int i;
// int: 데이터타입(자료형): 값을 저장할 메모리의 종류
// i: 변수: 메모리를 가리키는 이름
// 정수 값을 담을 메모리를 준비하고 그 메모리의 값을 i라고 하자!

int a, b, c;
```

#### 할당
![variable3](https://user-images.githubusercontent.com/50407047/88278231-0469a700-cd1d-11ea-8c40-f3758d25ddf7.jpg)
변수에 값을 할당하는 명령어는 L-value, R-value, 할당연산자로 이루어진다. R-value에는 값, 메모리, 심지어 **표현식(expression)**도 올 수 있다. 표현식은 Statement 중 하나로, 연산자와 피연산자 또는 여러가지 명령으로 묶여진, **결과를 리턴하는 문장(statement)**을 말한다. 

R-value에 표현식이 들어오는 예시는 다음과 같다.

```java
rValue1 = a + b;
rValue1 = a > b;
rValue3 = plus(a, b); // plus라는 메소드(함수)가 있다고 가정할 때
```

반면 L-value에는 값은 오지 못하고 메모리만 올 수 있다. 
```java
200 = 300;
``` 
이러지마..

각각의 명령어가 무엇을 **의미**하는 지 다음과 같이 말로 설명할 줄 알아야 한다. 
```java
byte b // 1바이트 정수 값을 담을 메모리를 확보하고 그 메모리의 이름을 b라고 하라
b = 12; // b라는 이름의 메모리에 12를 저장하라.
b = 32; // b라는 이름의 메모리에 38을 저장하라.
system.out.println(b) // b 메모리에 저장된 값을 출력하라.
```

#### 변수를 초기화해야 하는 이유

간단한 예제로 변수를 초기화하는 이유를 알아보자.

```java
int sum;
int k;

while (k <= 10){
  sum = sum + k;
}
```

위의 코드에서 sum과 k는 선언이 되었을 뿐 값은 할당되지 않았다.

##### Java와 C의 차이점
C언어의 경우 값을 초기화시키지 않을 경우, 쓰레기 값(garbage value)이 들어간다. 따라서 원하지 않는 값이 리턴될 수 있다. 반면 Java는 이러한 상황을 엄격하게 통제한다. 변수를 사용하기 전에 초기화를 반드시 시켜야 한다. 

변수를 쓰기 전에 적절한 디폴트 값을 설정해야 한다.

```java
int sum;
int k;

int sum = 0;
int k = 1;

while (k <= 10){
  sum = sum + k;
  k = k + 1;
}

System.out.println(sum); // 55
```


#### 부동소수점
[부동소수점 포스트 (업데이트 중)](https://hayeon17kim.github.io/java/2020/07/22/floating-point)

##### 부동소수점 연산과 GPU
부동소수점의 연산과 정수의 연산은 본질적으로 다르다. 컴퓨터에서 한 클락신호 당 하나의 작업을 하는데, 이 때마다 전기가 흐른다. (시간 당 몇 번의 클락이 발생하는 지에 대한 단위가 헤르쯔이고, 1기가헤르쯔는 초당 10억 클락이 발생한다.) 부동소수점의 연산은 정수 연산보다 훨씬 더 많은 클락을 사용하고, 이는 더 많은 전기를 cpu에 보내줘야 한다는 것을 의미한다. 이를 수행하기 위해 부동소수점 연산에 특화된 GPU(그래픽카드)가 필요하다. 부동소수점 연산을 하는 데 초당 많은 연산을 하기 때문에 열이 발생하고, 이것이 그래픽카드에 팬이 필요한 이유다.

##### CPU
CPU는 트렌지스터 덩어리로 3개의 선으로 구성된다. 전기가 들어가는 선, 들어온 전기를 제어하는 선, 전기가 나가는 선이 그것이다. 전기가 들어가는 선과 전기를 제어하는 선 끼리의 && 여부에 따라 1과 0이 결정된다. 전자의 선으로 전기가 들어오고, 후자의 선이 전기가 흐르도록 결정을 해야 1이 된다. 

##### 데이터타입 사용
부동소수점 연산에서 데이터타입을 일관적으로 사용해야 한다. 부동소수점 변수를 선언할 때 후에 이 변수로 연산을 할 것 같으면 유효자릿수가 큰 double로 통일하게 좋다. 물론 키나 몸무게처럼 유효자릿수가 작은 변수를 저장만 할 때는 float를 쓰는 것이 좋다.


# 느낀 점
부동소수점 이진법으로 바꾸는 방법 배울 때는 이런 것까지 알아야 하는 것인가..?!? 했는데 부동소수점 연산에서 이렇게 GPU의 팬까지 연결이 된다니 놀라워라... 오늘은 배운 것들이 맞물려서 이해가 되는 순간을 경험하였다. 커튼 뒤에서 어떤 일이 일어나는지에 대한 이해 없이 혼자서 코드만 치던 예전하고는 전혀 다른 공부를 하고 있는 것 같아 기뻤다! 
>>>>>>> 77868c5932abd9689afafdd1b0eb650fe6d46df6
