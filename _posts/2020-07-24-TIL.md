---
title: "✍ 200724_TIL"
categories: TIL
tags: [ TIL ]
toc: true
---

# 오늘 공부한 내용

## 강의노트
비트캠프 엄진영 강사님의 수업을 들으며 정리하였습니다.

### [자바 문법 몸소 체험하기](https://github.com/hayeon17kim/bitcamp-workspace/tree/master/bitcamp-java-project-04)

#### 1. 낱개의 변수를 사용하여 여러 회원 정보 처리하기
[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_a.java)

##### 배열의 중요성
```java
int no1, no2, no3, no4, no5;
String name1, name2, name3, name4, name5;
String email1, email2, email3, email4, email5;
String password1, password2, password3, password4, password5;
String photo1, photo2, photo3, photo4, photo5;
String tel1, tel2, tel3, tel4, tel5;
java.sql.Date now1, now2, now3, now4, now5;
long currentMillis;
```
혼돈 그 자체의 변수 선언.. 배열이 필요한 이유

##### 클래스의 패키지 정보 선언하기
```java
import java.util.Scanner;
```
위와 같이 클래스의 패키지 정보를 미리 선언하여 컴파일러에게 알려줄 수 있다. 위의 코드에서 Scanner가 java.util에 있는 Scanner라는 것을 먼저 알려주면 Scanner를 사용할 때 일일이 명시하지 않아도 된다!

```java
//import를 하지 않았을 때
java.util.Scanner keyInput = new java.util.Scanner(System.in);
//import를 해줬을 때
Scanner keyInput = new Scanner(System.in)
```

#### 2. 조건문을 사용하여 입출력 제어하기

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_b.java)

조건문을 사용하지 않은 1번에서는 정해진 인원(5명)만큼만 데이터를 입력받을 수 있었다. 조건문을 사용하여 필요한 만큼만 입력 받고 출력할 수 있게 되었다.


#### 3. 배열을 사용하여 여러 개의 값을 다루기
[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_c.java)

배열을 사용하면 간단하게 여러 개의 변수를 선언할 수 있다.

1번과 2번에서는 배열을 사용하지 않고 필요한 값 만큼 변수를 생성해주었다. 
그러나 이렇게 되면 100명의 데이터값을 입력받을 경우 무려 700개의 변수를 생성해줘야 한다...!! 
배열을 사용해보자.


```java
// 반복문을 사용하지 않았을 때
int no1 = 0, no2 = 0, no3 = 0, no4 = 0, no5 = 0;
String name1 = "", name2 = "", name3 = "", name4 = "", name5 = "";
String email1 = "", email2 = "", email3 = "", email4 = "", email5 = "";
String password1 = "", password2 = "", password3 = "", password4 = "", password5 = "";
String photo1 = "", photo2 = "", photo3 = "", photo4 = "", photo5 = "";
String tel1 = "", tel2 = "", tel3 = "", tel4 = "", tel5 = "";
java.sql.Date now1 = null, now2 = null, now3 = null, now4 = null, now5 = null;
```
으악!!!


```java
// 배열을 사용했을 때
int[] no = new int[5];
String[] name = new String[5];
String[] email = new String[5];
String[] password = new String[5];
String[] photo = new String[5];
String[] tel = new String[5];
Date[] now = new Date[5];

```


#### 4. 반복문을 사용하여 여러 개의 값을 다루기

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_d.java)

반복문을 사용하면 같은 코드를 중복해서 작성할 필요가 없다.


```java
// 반복문을 사용하지 않았을 때
System.out.printf("%d, %s, %s, %s, %s\n", no[0], name[0], email[0], tel[0], now[0].toString());
    if(count > 1) {
      System.out.printf("%d, %s, %s, %s, %s\n", no[1], name[1], email[1], tel[1], now[1].toString());
      if(count > 2) {
        System.out.printf("%d, %s, %s, %s, %s\n", no[2], name[2], email[2], tel[2], now[2].toString());
        if(count > 3) {
          System.out.printf("%d, %s, %s, %s, %s\n", no[3], name[3], email[3], tel[3], now[3].toString());
          if(count > 4) {
            System.out.printf("%d, %s, %s, %s, %s\n", no[4], name[4], email[4], tel[4], now[4].toString());
          }
        }
      }
    } 

// 반복문을 사용했을 때
​```java
for (int i = 0; i < count; i++) {
    System.out.printf("%d, %s, %s, %s, %s\n", 
        no[i], name[i], email[i], tel[i], now[i].toString());
}
```

#### 배열 개수를 변수에서 관리하기

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_e.java)

변수의 값만 바꾸면 배열 개수를 바로 변경할 수 있어 편하다.

```java
// 배열 개수를 관리하는 변수가 없을 때
int[] no = new int[5];
String[] name = new String[5];
String[] email = new String[5];
String[] password = new String[5];
String[] photo = new String[5];
String[] tel = new String[5];
Date[] now = new Date[5];

// 배열 개수를 관리하는 변수를 선언했을 때

int maxLength = 5;

int[] no = new int[maxLength];
String[] name = new String[maxLength];
String[] email = new String[maxLength];
String[] password = new String[maxLength];
String[] photo = new String[maxLength];
String[] tel = new String[maxLength];
Date[] now = new Date[maxLength];
```

#### 상수를 사용하여 초기 값을 변경하지 못하게 막기

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_f.java)

변수는 중간에 값을 바꿀 수 있기 때문에 값을 바꾸지 말아야 하는 경우 상수로 선언한다.

```java
// 변수 선언
int maxLength = 5;

// 상수 선언
final int MAX_LENGTH = 5;
```

#### 매서드를 사용하여 코드를 분리하기

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_g.java)

매서드를 사용하면 기능별로 코드를 별도의 블럭으로 분리할 수 있다. 이처럼 작은 단위로 코드가 분리되면 관리하기 쉽다.

이전에는 main 매서드에서 모든 기능을 넣었지만, main, inputMembers(), printMembers() 매서드로 기능에 따라 코드를 분리하였다.

```java
public class App_g {
  static int count = 0;
  static final int MAX_LENGTH = 5;
  static int[] no = new int[MAX_LENGTH];
  //(...)
  
  public static void main(String[] args){
    inputMembers();
    printMembers();
  }

  static void inputMembers() {
    Scanner keyInput = new Scanner(System.in);
    long currentMillis = 0;

    for (int i = 0; i < MAX_LENGTH; i++){
      count ++;

      System.out.print("번호? ");
      no[i] = keyInput.nextInt();
      keyInput.nextLine();
      //(...)     

      currentMillis = System.currentTimeMillis();
      now[i] = new Date(currentMillis);
      
      System.out.println("");
      
      System.out.println("계속 입력하시겠습니까?(y/N) ");
      
    
      String response = keyInput.nextLine();
      if (response.equalsIgnoreCase("y") == false) {
        break;
    }
  }
  keyInput.close();
}

static void printMembers() {
  for (int i = 0; i < count; i++) {
    System.out.printf("%d, %s, %s, %s, %s\n", 
        no[i], name[i], email[i], tel[i], now[i].toString());
  }
}
```

#### 클래스를 사용하여 데이터를 담을 메모리를 정의한다.

[소스코드 바로가기](https://github.com/hayeon17kim/bitcamp-workspace/blob/master/bitcamp-java-project-04/src/main/java/com/eomcs/pms/App_h.java)

번호, 이름, 이메일 등 각각의 데이터를 낱개로 다루는 것보다 하나의 데이터로 묶어서 다루면 값을 다루기가 편하다. 

```java
public class App_h {
  
  static class Member {
    int no;
    String name;
    String email;
    String password;
    String photo;
    String tel;
    Date now;
  }
  
  static int count = 0;
  static final int MAX_LENGTH = 5;
  static Member[] members = new Member[MAX_LENGTH];

  public static void main(String[] args) {

    System.out.println("[회원]");
    
    inputMembers();  // 별도의 블럭으로 분리한 코드를 실행하기 
    
    System.out.println("--------------------------");
    
    printMembers();
    
  }
  
  static void inputMembers() {
    
    Scanner keyInput = new Scanner(System.in);
    long currentMillis = 0;
    
    for (int i = 0; i < MAX_LENGTH; i++) {
      count ++;
      Member m = new Member();
      
      // 식판에 음식물을 담는다.
      System.out.print("번호? ");
      m.no = keyInput.nextInt();
      keyInput.nextLine();
        
      // (...)
        
      //식판을 배선카에 꼽는다.
      members[i] = m;
      
      System.out.println("계속 입력하시겠습니까?(y/N) ");
      
      String response = keyInput.nextLine();
      
      if (response.equalsIgnoreCase("y") == false) {
        break;
      }

    }
    keyInput.close();
  }
  
  static void printMembers() {
    for (int i = 0; i < count; i++) {
      Member m = members[i];
      System.out.printf("%d, %s, %s, %s, %s\n", 
          m.no, m.name, m.email, m.tel, m.now.toString());
    }
  }
  
```



# 느낀 점

개념으로만 이해하고 있던 배열, 조건문, 반복문, 상수, 매서드, 클래스를 차례로 적용해보면서 왜 필요한 지 이해하게 되었다.