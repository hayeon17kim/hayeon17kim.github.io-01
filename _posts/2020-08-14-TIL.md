---
title: "✍ 200814_TIL: [java] String, wrapper 클래스, 객체 생성 디자인 패턴, ArrayList"
categories: TIL
tags: [ TIL ]
toc: true
---

# String Class

[String 클래스 포스트 바로가기](https://hayeon17kim.github.io/java/string)

# Wrapper Class

[wrapper 클래스 포스트 바로가기](https://hayeon17kim.github.io/java/wrapper-class)

# 생성자 활용

## java.util.Date

```java
// Date() 기본 생성자
Date d1 = new Date(); // 현재 시간을 저장한다.
System.out.println(d1); //Sun Aug 16 14:41:19 KST 2020

// Date(long): 1970-01-01 00:00:00 부터 지금까지 경과된 밀리초
Date d2 = new Date(1000);
System.out.println(d2);//Thu Jan 01 09:00:01 KST 1970

Date d3 = new Date(System.currentTimeMillis());
System.out.println(d3);//Sun Aug 16 14:41:19 KST 2020

Date d4 = new Date(199, 0, 15);
System.out.println(d4);//Thu Jan 15 00:00:00 KST 2099

// java.sql.Date
java.sql.Date d5 = new java.sql.Date(System.currentTimeMillis());
System.out.println(d5);//2020-08-16

// 간접적으로 객체 생성하기
java.sql.Date d6 = java.jql.Date.valueOf("2019-1-16");
System.out.println(d6);//2019-01-16
```



## java.util.Calendar
```java
Calendar c1;

// 생성자가 있다하더라도 접근 권한이 없으면 호출할 수 없다.
// c1 = new Calendar(); // 컴파일 오류!

// Calendar는 인스턴스 생성을 도와주는 별도의 클래스 메서드(스태틱 메서드)를 제공한다.
c1 = Calendar.getInstance();
System.out.println(c1.get(Calendar.YEAR));
```




## 객체 생성 디자인 패턴

### 팩토리 메서드(factory method)

- GoF(Gang of Four)의 23가지 디자인 패턴 중 하나이다.
- 인스턴스를 생성해주는 메서드이다.
- 인스턴스 생성 과정이 복잡한 경우 인스턴스를 생성해주는 메서드를 미리 정의해 둔다.
- 그래서 인스턴스가 필요할 때마다 메서드를 호출하여 인스턴스를 리턴받는다.
- 예) `Calendar.getInstance()`



### 싱글톤(singleton)

- GoF(Gang of Four)의 23가지 디자인 패턴 중 하나이다.
- 인스턴스를 한 개만 생성하도록 제한할 때 사용한다.
- 생성자를 private으로 처리하여 직접 인스턴스를 생성하지 못하도록 만든다.
- 메서드를 통해 인스턴스를 생성하도록 유도한다.



## 주의

생성자를 호출할 수 있는 경우

1. new 명령을 사용할 때

2. 생성자에서 다른 생성자를 호출할 때

그 외에는 임의로 생성자를 호출할 수 없다.



# ArrayList

- 컬렉션 클래스(collection class): **객체(의 주소) 목록**을 다루는 클래스
- 인스턴스 자체는 관리할 수 없다. 그건 JVM이 하는 일이다. 우리가 관리하는 것은 인스턴스의 주소일 뿐이다. 

## 단점

- 배열의 크기가 고정되기 때문에 배열을 초과하여 값을 넣으려면 더 큰 새 배열을 만들고, 기존 값을 복사해야 한다. 
- 배열의 크기가 늘 때마다 가비지(garbage)가 생긴다.
- 기존 배열의 값을 복사하기 때문에 속도가 느리다.

##  ArrayList의 객체 비교: equals()

- ArrayList가 객체를 비교할 때 equals()를 사용한다. 

- `contains()`와 `indexOf()`는 각 객체에 대해 `equals()`를 호출하여 비교한다. 따라서 `equals()`를 오버라이딩하지 않을 경우, 해당 메서드의 결과가 원하는 대로 나오지 않을 것이다. 

> 그냥 모든 Domain 클래스는 무조건 equals()와 hashCode()를 오버라이딩 하자.
>
> - hashCode()도 같이 오버라이딩 하는 이유: hashSet과 hashMap을 사용할 때 hashCode() 메서드를 활용한다.

## ArrayList 만들기

배열을 이용하여 컬렉션 클래스를 만들어보자.

``` java
public class ArrayList {
    protected static final int DEFAULT_CAPACITY = 5;
    
    Object[] list;
    int cursor;
    
    public ArrayList() {
        this(DEFAULT_CAPACITY);
    }
}

public ArrayList(int capacity) {
    if (capacity < DEFAULT_CAPACITY) {
        list = new Object[Default_CAPACITY];
    } else {
        list = new Object[capacity];
    }
}

public void add(Object value) {
    if (cursor >= list.length) {
        this.increaseArray();
    } 
    list[cursor++] = value;
}

public Object(int index) {
    return list[index];
}

public void set(int index, Object value) {
    list[index] = value;
}

public void remove(int index) {
    if (index < 0 || index >= cursor)
        return;
    for (int i = index + 1; i < cursor; i++) {
        list[i - 1] = list[i];
    }
    cursor--;
}

public void add(int index, Object value) {
    if (index < 0 || index > cursor)
        return;
    if (cursor >= list.length) {
        this.increaseArray();
    }
   	for (int i = cursor - 1; i >= index; i--) {
        list[i + 1] = list[i];
    }
    list[index] = value;
    cursor++;
}

private void increaseArray() {
    Object[] list2 = new Object[list.length + DEFAULT_CAPACITY];
    for (int i = 0; i < list.length; i++) {
        list2[i] = list[i];
    }
    list = list2;
}

public int size() {
    return cursor;
}

public boolean contains(Object value) {
    for (Object obj : list) {
        if (obj.equals(value))
            return true;
    }
    return false;
}

public int indexOf(Object value) {
    for (int i = 0; i < list.length; i++) {
        if (list[i].equals(value))
            return i;
    }
    return -1;
}
```





