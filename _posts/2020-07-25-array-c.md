---
title: "🍵 포인터 변수와 배열 feat. C언어"
categories: c
tags: [ c, java ]
toc: true
---

## c언어에서 배열 사용하기
C언어에서는 자바와 달리 직접 주소값을 조회할 수 있고 수정할 수도 있어 자바의 레퍼런스(reference)(포인터와 같은 개념) 개념을 이해하기 좋다. 

### c언어의 규칙 

데이터타입에 따라 메모리가 정해져 있는 Java와 달리, c언어에서는 메모리는 운영체제에 따라 달라진다. 16비트 운영체제에서 int는 16비트, 32비트 운영체제에서는 32비트이다. 이때 CPU가 몇 비트인지는 중요하지 않다. Java는 운영체제에 상관 없이 무조건 4바이트이다.

### 리눅스에서 c언어 소스코드 컴파일하기


1. 컴파일하기 `gcc -o hello hello.c `
  - `gcc`: gnu 오픈소스 프로젝트의 패키지
  - `-o hello`: hello이름으로 컴파일하기
  - `hello.c`: 컴파일할 소스코드

2. 실행하기: `./hello`

### 주소를 담는 변수 사용하기: 배열X

```c
#include <stdio.h>
#include <stdlib.h>
// 레퍼런스
int main() {
  int i1, i2, i3;
  i1 = 100;
  i2 = 200;
  i3 = 300;
  
  // 주소를 담는 변수 = 포인터(pointer)
  int* p;
  
  //i1에 들어있는 값이 아니라 i1 메모리의 주소를 이 자리에 넣어라.
  p = &i1;
  //p에 들어있는 주소로 찾아가서 그 메모리의 값을 출력하라.
  printf("%d(%x) --> %d\n", p, p, *p);	//-1290692204(b3119994) --> 100
  
  p= &i2;
  printf("%d(%x) --> %d\n", p, p, *p);	//852309736(32cd36e8) --> 200
  
  p = &i3;
  printf("%d(%x) --> %d\n", p, p, *p);	//-1382156852(ad9df5cc) --> 300
  
  *p = 500;
  printf("%d\n", i3);					//500
  
  return 0;
}
```

여기서 변수 p는 주소를 담는 변수로, C언어에서는 이를 **포인터(pointer)**라 부른다. 여기서 메모리 주소는 메모리의 첫번째 바이트의 주소이다. 



### 주소를 담는 변수 사용하기: 배열O

```java
  int i[3];
  i[0] = 100;
  i[1] = 200;
  i[2] = 300;
  
  printf("%d, %d, %d\n", i[0], i[1], i[2]);

  p = &i[0];
  printf("%d\n", p, *p);	//-290063748, 100

  p = &i[1];
  printf("%d\n", p, *p);	//-290063752, 200

  p = &i[2];
  printf("%d\n", p, *p)		//-290063756, 300
```

주소값을 출력해보면 각각의 인덱스는 int의 단위인 4바이트로 나누어진다. 배열은 **연속된 메모리**라는 것을 알 수 있다. 