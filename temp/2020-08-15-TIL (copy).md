---
title: "✍ 200819_TIL: 미니 프로젝트"
categories: TIL
tags: [ TIL ]
toc: true
---

## 클래스 의존 관계
- 크로스하면 안된다!! 
- App입장에서는 MemberHandler, Project Handler는 의존객체
- MemberHandler가 컴파일되면 projectHandler가 컴파일됨
- 요즘은 컴파일러가 좋아서 그렇게까지는 안감
- 쌍방향 레퍼런스 금지!: 서로 쌍방향으로 참조되면 크로스 어쩌구로 무한으로 돌게 됨
- 쌍방향 레퍼런스를 쓸 수밖에 없는 상태면 인터페이스를 통해 ~ 



### UML

- 상속: 
- 연관 app -> BoardHandler 사용 - BoardHandler를 컴파일하지 않으면 App을 실행할 수 없다는 뜻
- 집합(): 항상 목적어 쪽으로 화살표가 간다.  
- BoardHandler -> Board
- 합성(Composition): LinkedList -> Node
  - linkedlist가 사라질 때 Node도 사라짐
  - 강집합 관계

- 의존(dependency):
  - 특정 메서드 안에서 특정 클래스를 사용할 때. 이 기능을 사용하려면 이 클래스를 사용할 수밖에 없음. 일시적



- 객체지향 전체적으로 봤을 때는 의존관계라고 함.

- 그러나 UML에서는 이렇게 말하지만 객체지향 프로그래밍에서는 퉁쳐서 전체를 다 의존관계라고 하기도 함. 따라서 상황에 따라서 좁혀서 표현할 경우도 있고, 또 다른 경우는 전체적으로 퉁 쳐서 말할 때도 있으니까 맥락 파악하기!



## v11 클래스 필드와 클래스 메서드의 한계

**클래스 필드(스태틱 필드)**는 클래스를 로딩할 때 생성된다. 클래스는 최초 사용 시점에 **한 번만 로딩**되기 때문에 스태틱 필드도 **한 번만 생성**된다.

클래스 필드 상태에서 기능을 확장하는 방법과 그 문제점을 확인한다.



**1단계: ** 새 게시판을 추가한다.

```java
Board[] list = new Board[LENGTH];
int size = 0;
```

**2단계:** BoardHandler의 인스턴스 멤버를 사용하여 게시글 등록/목록 조회를 처리한다.

```java
this.list[this.size++] = b;
```

**3단계:** **새 게시판을 추가한다.** 

1) **기존 소스파일에서 멤버를 복사해서 추가한다.**

2)  **새로운 클래스를 정의한다. (기존 클래스 복붙)**



**4단계**: 회원관리와 프로젝트 관리, 작업 관리에도 향후 확장성을 고려하여 인스턴스 멤버로 전환한다.  









### 인스턴스 멤버 vs 클래스 멤버

- 실무에서는 처음부터 인스턴스 필드로 만든다. 

- 공부를 하는 입장이기 때문에 클래스 멤버로 선언했다가 필요성(불편함)을 깨닫고 그제서야 인스턴스 멤버를 사용ㅎ면서 필요성 절감



### NullPoint Exception Error

인스턴스 주소 없이 인스턴스 메서드 호출할 때. 인스턴스 주소 대신 null이 있음.

- 이래서 생성자를 만드는 것 !!!
- 의존객체 : Dependency Object 

```java
    ProjectHandler projectHandler = new ProjectHandler();
    // ProjectHandler의 의존객체 주입을 막는다.
    //projectHandler.memberHandler = memberHandler;
    
    TaskHandler taskHandler = new TaskHandler();
    // ProjectHandler의 의존객체 주입을 막는다.
    //taskHandler.memberHandler = memberHandler;
```



생성자를



# v16

## UI처리하는 코드와 데이터 처리하는 코드 분리

객체지향 프로그래밍을 할 때 Low Coupling과 High Cohesion을 명심해야 한다.

### Low Coupling(관계도 낮추기)

한 클래스가 많은 클래스에 의존하는 구조로 작성하면 의존 클래스가 변경될 때마다 영향을 받기 때문에 유지보수에 좋지 않다. 그래서 가능한 의존하는 클래스의 접점을 줄이는 구조로 만드는 것이 좋다. 

(관계도 낮추기 => 의존 클래스의 변경에 둔감 => 코드 변경이 줄어듦)

### High Cohesion(응집력 강화)

한 클래스가 너무 다양한 역할을 수행하면 클래스 코드가 커지고 변경 사항이 잦아지기 때문에 유지보수에 좋지 않다. 그래서 가능한 한 클래스가 한 개의 역할만 수행하게 만드는 것이 유지보수에 좋다. 역할을 작게 쪼개게 되면 해당 클래스를 다른 프로젝트에서 재사용하기가 쉽다. 

(응집력 강화 => 클래스를 잘게 쪼갬 => 교체가 용이하고 재사용성이 높아짐)

- 핸드폰은 뭐가 잘못되거나 추가하려면  메인보드 전체를 갈아야 하지만, 자동차에서 문제가 생기거나 추가하려고 하면 부품을 교체하거나 추가하면 된다. 
- 한 사람이 하나의 일을 하게 하면 그 사람이 다른 사람에 의해 쉽게 교체될 수 있음 (분업화)
- 코드를 경영하는 경영자 입장으로 생각해라. 
- XxxHandler 클래스는 사용자와 소통하는 역할을 수행할 뿐만 아니라 데이터를 관리하는 역할도 수행한다. 이 것을 사용자의 소통을 담당하는 **UI 역할** 클래스와 데이터 처리를 담당하는 **DAO(Data Access Object) 역할** 클래스로 분리하였다.
- 이를 통해 추루 데이터 처리 부분을 다른 클래스로 교체하기 쉬워진다. ex) 지금은 데이터를 배열에 보관하고 있지만, 나중에는 파일이나 DBMS에 보관하는 클래스로 교체하기가 쉬워진다.
- 또한 지금은 CLI(Command Line Interface) 방식으로 UI를 처리하고 있지만, 나중에는 웹으로 처리하는 클래스로 교체하기가 쉬워진다. 



- BoardHandler에서 데이터 처리 코드를  분리하여 BoardList클래스로 정의한다.
- BoardList의 기본 생성자와 배열으 ㅣ초기 크기를 설정하는 생성자를 정의한다.
- BoardList에 Board객체를 등록하는 add()를 정의한다.
- BoardList에 데이터 목록을 리턴하는 toArray()메서드를 정의한다.
- BoardHandler는 BoardList를 사용하여 입, 출력 데이터를 처리한다.





- 여러 클래스에서 공유하는 클래스는 중첩 클래스로 정의하기 보다는 패키지 멤버 클래스로 정의하면 관리하기가 더 쉽다. 
- Board나 Member처럼 데이터 타입 역할을 하는 클래스를 **도메인(domain)** 클래스라 부른다. 



- Board핸들러에서만 사용할 클래스는 그 안에서 만들어라. 중첩 클래스가 디폴트임. 그러다가 다른 클래스가 사용해서 불편하다면 그때서야 분리해라. 







