---
title: "✍ 200813_TIL: [Java] 객체지향적 관점, 오버로딩, 오버라이딩, 캡슐화"
categories: TIL
tags: [ TIL ]
toc: true
---

# 객체지향

![oop](https://user-images.githubusercontent.com/50407047/90085361-c0355980-dd52-11ea-9bea-0066b8f8839a.jpg)

- Actor: 어플리케이션이 동작하게 만드는 촉발점
- 요청하지도 않았는데 스스로 동작하는 경우: ex) 고객의 자산정보 자동으로 보냄 (지정된 시간이 있으면 보냄 )
- 자신의 업무 중에서 사람, 사물, 개념을 application을 통해 관리하고 싶은 것. 그러려면 사람, 사물, 개념에 관련된 데이터를 정의해야 한다. 이렇게 일단 추상화를 하고 부가적인 문법(상속, 다형성, 캡슐화)을 통해서 프로그래밍.



# java.lang.Object

클래스를 정의할 때 수퍼 클래스를 지정하지 않으면 컴파일러는 자동으로 Object를 상속 받는다.

## 확인

```java
Object obj = new My();
System.out.println(obj instanceof Object); //true
System.out.println(obj instanceof String); // false
System.out.println(obj.toString()); //true //com.eomcs.corelib.ex01.Exam0110$My@d716361
//@고유해시값: 메모리 주소가 아니다.
System.out.println(obj.hashCode());
//225534817
//16진수를 10진수로 푼 것
System.out.println(obj.equals("Hello")); // false
```

항상 자식은 부모 인스턴스의 변수를 모두(무조건) 포함하고 있기 때문에 부모 레퍼런스로 가리킬 수 있는 것이다.

Object 클래스의 주요 메서드
- `toString()`: 클래스 정보(클래스이름과 해시코드)를 리턴한다.
- `equals()`: 같은 인스턴스인지 검사한다. 
- `hashCode()`: 인스턴스를 식별하는 값을 리턴한다.
- `getClass()`: 인스턴스의 클래스 정보를 리턴한다.
- `clone()`: 인스턴스를 복제한 후 그 복제 인스턴스를 리턴한다.
- `finalize()`: 가비지 컬렉터에 의해 메모리에서 해제되기 직전에 호출된다.

## toString()

- 클래스 정보(클래스이름과 해시코드)를 리턴한다.
  - 패키지명.클래스명@16진수해시값 예) ch15.My1@1e81f4dc
  - 해시값이란 인스턴스마다 부여된 고유의 식별자(주소X)이다. 인스턴스가 같은 지 검사할 때 사용할 수 있다. 

>  해시값: 인스턴스 마다 부여된 고유의 식별자이다(주소 X). 인스턴스가 같은지 검사할 때 사용할 수 있다. hashCode()을 재정의하지 않고 원래 메서드를 그대로 사용하면 무조건 인스턴스마다 새 해시값이 부여된다. 

- println()에 넘겨주는 값이 String 타입이 아니라면 println()은 그 객체에 대해 toString() 호출한 후 그 리턴 값을 출력한다.
  - 인스턴스의 주소값이 아니라 현재 값을 확인하고 싶을 때 toString()을 오버라이딩

```java
// 개발을 하다 보면 인스턴스의 현재 값을 간단히 확인하고 싶을 경우가 있다.
// 그럴 경우 toString()을 오버라이딩 하라!
@Override
public String toString() {
  return "My3 [name=" + name + ", age=" + age + "]";
}
```



### println()


```java
System.out.println(obj.toString());
System.out.println(obj);
```

    
    
        // println()의 파라미터 값으로 문자열을 넘겨주지 않으면,
        // println() 내부에서 파라미터로 넘어온 객체에 대해 toString() 호출한 후 
        // 그 리턴 값을 출력한다.
        // 따라서 그냥 객체(주소)를 넘겨줘도 된다.
        
            Score s1 = new Score("홍길동", 100, 100, 100);
        
        String str = s1.toString();
        // toString()?
        // => Score 클래스의 수퍼 클래스인 Object의 메서드이다.
        // => 클래스를 정의할 때 수퍼 클래스를 지정하지 않으면 
        //    자동으로 java.lang.Object 클래스가 수퍼 클래스로 지정된다.
        // => 그래서 자바의 모든 클래스는 toString()을 호출할 수 있다.
        //    즉 자바의 모든 클래스는 Object 클래스에 정의된 메서드를 호출할 수 있다.
        
        System.out.println(str);
        // toString()의 리턴 값?
        // => Object의 toString()을 호출하면 다음 형식의 문자열을 리턴한다. 
        //       "패키지 이름을 포함한 클래스명@인스턴스 식별자"
        // 예) com.eomcs.oop.ex06.d.Exam0110$Score@12a74311
        //
        // 인스턴스 식별자?
        // => 인스턴스의 주소가 아니다. 자바는 절대로 메모리 주소를 알려주지 않는다!
        // => 단지 인스턴스를 식별할 때 사용하라고 JVM이 임의로 붙인 식별자이다.
        // => 이 식별자를 "해시값(hashcode)"라 부른다.
    // Object로부터 상속 받은 toString()의 리턴 값이 마음에 들지 않는다면 
    // 재정의하라!
    // => 보통 인스턴스의 내부 데이터를 문자열로 리턴하도록 변경한다.
    // => 프로그램을 실행하는 중에 인스턴스의 내부 값을 빠르게 확인하고 싶을 때 
    //    개발자들이 종종 이 메서드를 오버라이딩 한다.
    //
    
    // 스태틱 메서드 
        @Override
        public String toString() {
          return String.format("%s,%d,%d,%d,%d,%.1f",
              this.name, this.kor, this.eng, this.math, 
              this.sum, this.aver);
        }
      }
      
          Score s1 = new Score("홍길동", 100, 100, 100);
        
        String str = s1.toString();
        // Score 클래스에서 Object의 toString()을 오버라이딩 했기 때문에,
        // Score의 toString()을 호출한다.
        
        System.out.println(str);
    
        // println()에 String이 아닌 객체를 넘기면,
        // println()에서 내부적으로 그 객체에 대해 toString()을 호출하여
        // 그 리턴 값을 출력한다.
        // 따라서, 다음 코드는 위의 코드와 같은 결과를 출력한다.
        System.out.println(s1);
        // 그러니 println()으로 객체의 값을 출력할 때 
        // 굳이 toString()을 번거롭게 호출하지 말라! 
### 해시값

- 일종의 디지털 지문

​    // 인스턴스 식별자?
​    // => 인스턴스의 주소가 아니다. 자바는 절대로 메모리 주소를 알려주지 않는다!
​    // => 단지 

```java
hashCode {
	return 100;
}
    System.out.println(obj2 == obj3); // false
System.out.println(obj2.toString()); //@64
    System.out.println(obj3.toString()); //@64
//즉, 해시코드는 주소가 아니다!!!
```



## equals()

- 데이터 타입을 정의한 클래스의 경우 보통 toString과 equals를 오버라이딩 한다.
- 이클립스는 equals를 자동으로 오버라이딩 해주는 기능 있음

```java
    My obj1 = new My();
    obj1.name = "홍길동";
    obj1.age = 20;
    
    My obj2 = new My();
    obj2.name = "홍길동";
    obj2.age = 20;
    
    System.out.println(obj1 == obj2);
    
    // Object에서 상속 받은 equals()는 == 연사자와 마찬가지로 인스턴스가 같은지를 비교한다.
    // 만약 그 내용물이 같은지 비교하고 싶다면 equals()를 재정의 하라!
    System.out.println(obj1.equals(obj2));
```
- Object에서 상속 받은 것을 그대로 사용하면 equals()는 인스턴스가 같은지 비교한다.
- 내용물이 같은지 비교하고 싶다면 재정의하라
- 인스턴스의 내용물이 같은지 비교하도록 만들고 싶다면 equals()을 오버라이딩 하라!
- String와 wrapper 클래스는 equals() 오버라이딩 하였다.
- StringBuffer 클래스는 equals()를 오버라이딩 하지 않았다.

        // => String 클래스에서 Object의 toString()을 오버라이딩 했기 때문이다.
        // => 인스턴스가 다르더라도 문자열이 같으면 true를 리턴하도록
        //    toString() 메서드를 재정의하였다.
        // => 그래서 String에 대해 equals()를 호출하면 
        //    Member와 달리 true를 리턴한다.
        //
        // Member 객체에 대해서도 인스턴스가 다르더라도 
        // 데이터가 같으면 true를 리턴하도록 하고 싶은가?
        // => String 클래스처럼 toString()을 오버라이딩 하라!
        // => Exam0320.java를 보라!
    
- 메서드의 파라미터의 값이 오브젝트면? 어떤 객체의 주소를 다 받겠다는 뜻.



// 결론!
// => Object로부터 상속 받은 기본 메서드인 equals()는 
//    같은 인스턴스인지를 비교하는 메서드이다.
// => 인스턴스의 데이터가 같은지를 비교하고 싶다면, 
//    이 메서드를 재정의(오버라이딩) 해야 한다.
// => 오버라이딩의 예:
//    String, 
//    랩퍼 클래스(Byte,Short,Integer,Long,
//    Float,Double,Boolean,Character)
// 



    // sb1.equals(sb2)의 리턴 값은 false이다.
    // 이유?
    // StringBuffer는 Object로부터 상속 받은 equals()를 오버라이딩 하지 않았다.
    // 그래서 Object의 equals()가 호출된 것이다.
    // Object의 equals()는 데이터가 같은지를 비교하는 것이 아니라,
    // 인스턴스가 같은지를 비교한다.
## API 메뉴얼 보기

- | `boolean` | `equals(Object obj)` | Returns `true` if and only if the argument is not `null` and is a `Boolean` object that represents the same `boolean` value as this object. |
  | :-------- | -------------------- | ------------------------------------------------------------ |
  |           |                      |                                                              |

- 재정의한 메서드들은 위의 목록에 나타나고 수퍼클래스 목록에는 안 나타남



## hashCode()

### hashCode()에 대하여

![git-hashcode](https://user-images.githubusercontent.com/50407047/90088719-9122e600-dd5a-11ea-8dff-997bd96b7eef.png)

- 데이터를 다른 데이터와 구분하기 위해 사용하는 특별한 정수 값
- 데이터가 같은 지 비교할 때 주로 사용해 "디지털 지문"이라고도 한다. 
- 예시: 인증서, 파일 위변조 검사(git에서 커밋할 때 붙이는 고유번호, 파일 다운로드 사이트에서 제공하는 해시값, 파일 공유사이트에서 파일 구분할 때 사용하는 해시값)
- 해시 알고리즘: SHA, MD(Message Digest, 메시지 요약), PGP 등
- 인스턴스를 식별할 때 사용하라고 JVM이 임의로 붙인 식별자이다.

### hashCode() 오버라이딩

- 이유: 해시코드를 데이터를 구분하는 지문과 같다. 인스턴스(메모리)가 다르더라도 같은 데이터를 갖는 경우 같은 것으로 취급하기 위해 이 메서드를 재정의한다 .두 개의 인스턴스가 같은 데이터인지 비교하기 위해서!
  - 모든 인스턴스에 대해 같은 해시코드를 리턴하는 것은 의미 없는 일이다. 
  - 

- hashCode()를 오버라이딩 할 때 equals()도 함께 오버라이딩 한다. 보통 값이 같은지 비교할 때 equals()와 함께 사용된다.



### hash code 응용: HashSet과 hashCode()



# Wrapper Class

### java.lang.[래퍼(wrapper) 클래스]

#### wrapper 클래스란?

기본타입 데이터를 객체로 취급해야 하는 경우가 있다. 예를 들어, 메서드의 인수로 객체 타입만이 요구되면, 기본형 타입의 데이터를 그대로 사용할 수는 없다. 이때 8개 기본 타입에 해당하는 데이터를 객체로 포장해주는 [wrapper class(래퍼 클래스)](http://tcpschool.com/java/java_api_wrapper)를 사용할 수 있다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 아규먼트로 전달 받아, 해당 값을 가지는 객체로 만들어준다.

| 기본 타입 | 래퍼 클래스   |
| --------- | ------------- |
| byte      | Byte          |
| short     | Short         |
| int       | **Integer**   |
| long      | Long          |
| float     | Float         |
| double    | Double        |
| char      | **Character** |
| boolean   | Boolean       |

#### 객체 생성

- `new Integer(값)`: **생성자**를 통해 Integer 객체를 생성할 수 있지만 사용하지 말라고 권고하였기 때문에 가능한 **사용하지 않는 것이 좋다**.
- `Integer.valueOf(값)`: **클래스 메서드**를 사용하여 Integer 인스턴스를 생성하자.
  - valueOf으로 인스턴스를 만들 때 값이 같으면 heap에 각각 따로 메모리를 만들지 않는다.



# String Class

