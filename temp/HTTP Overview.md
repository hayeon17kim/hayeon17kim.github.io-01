# HTTP 개요

## HTTP란?

- 웹에서 이루어지는 모든 데이터 교환의 기초
- 클라이언트-서버 프로토콜: 수신자 측에 의해 요청이 초기화되는 프로토콜
  - 요청: 클라이언트(브라우저)에 의해 전송되는 메시지
  - 응답: 서버에서 응답으로 전송되는 메시지
- 애플리케이션 계층의 프로토콜
- 확장 가능한 프로토콜: 문서뿐만 아니라 이미지, 비디오 혹은 HTML 폼 결과 등을 서버로 포스트 하는 데 사용할 수 있음



## HTTP 기반 시스템의 구성 요소

- 클라이언트-서버 프로토콜
- 클라이언트: 사용자 에이전트
  - 요청을 보내는 개체
  - 사용자를 대신하여 동작하는 모든 도구(브라우저)
  - HTML문서 요청 가져옴 => 파일 구문분석 => 스크립트 및 CSS 요청 가져옴 => 리소스 혼합. (스크립트는 이후 더 많은 리소스를 가져올 수 있으며 브라우저는 그에 따라 웹 페이지 갱신)
- 서버: 클라이언트 요청에 대한 문서를 제공
- 프록시
  - 애플리케이션 계층에서 동작하는 것들 (전송, 네트워크, 물리 계층이 아님)
  - 다양한 기능 수행 가능 (캐싱, 필터링, 로드 밸런싱, 인증, 로깅)



## HTTP 기초

### 간단

HTTP 메시지를 프레임별로 캡슐화하여 간결함을 유지한 덕분에 사람이 읽고 이해할 수 있어 테스트하기 쉽다.

### 확장 가능

언제든지 새로운 기능을 추가할 수 있다.

### 상태가 없지만, 세션은 있다

상태를 저장하지 않아 연속으로 전달된 요청이라도 둘 사이에는 연결고리가 없다. 이때 HTTP 쿠키는 상태가 있는 세션을 만들도록 해준다. 헤더 확장성을 사용하여 동일한 컨텍스트를 공유하기 위해 각각의 요청들에 세션을 만들도록 HTTP 쿠키가 추가된다.

### HTTP와 연결

연결은 HTTP 영역 밖이고, 다만 HTTP는 신뢰할 수 있거나 메시지 손실이 없는 연결을 요구할 뿐이다. 따라서 HTTP는 신뢰할 수 있는 TCP 표준에 의존한다. 

클라이언트와 서버가 HTTP를 요청/응답으로 교환하기 전에 TCP연결을 설정해야 한다. HTTP/1.0은 각 요청/응답에 대해 별도의 TCP를 열었는데, 이 경우 여러 요청을 연속적으로 보낼 때 효율적이지 못하다. 따라서 HTTP/1.1은 **파이프라이닝** 개념과 지속적인 연결의 개념을 도입했다. HTTP/2는 이에 더해 단일 연결 상에서 메시지를 다중 전송할 수 있다.

## HTTP로 제어할 수 있는 것

### 캐시

HTTP는 문서가 캐시되는 방식을 제어할 수 있다. 

- 서버: 캐시 대상과 기간을 프록시와 클라이언트에 지시 가능
- 클라이언트: 저장된 문서 무시하라고 중간 캐시 프록시에 지시 가능

###  origin 제약사항을 완화하기

- 스누핑과 프라이버시 침해를 막기 위해 브라우저에는 동일한 origin으로부터 온 페이지만이 웹 페이지의 전체 정보에 접근할 수 있다는 제약사항이 있다. 그러나 HTTP헤더를 통해 이러한 제약사항을 완화하여 다른 도메인으로부터 전달된 정보를 **패치워크**할 수 있다. 

### 인증

웹페이지를 보호하여 특정 사용자만이 접근할 수 있게 한다.

- HTTP를 통해 WWW-Authenticate 혹은 유사한 헤더를 사용
- HTTP쿠기를 사용해 특정 세션을 설정

### 프록시와 터널링

서버 혹은 클라이언트는 인트라넷에 위치하여 다른 개체들에게 실제 주소를 숨기기도 한다. 이때 HTTP 요청은 네트워크 장벽을 가로지르기 위해 프록시를 통해 나간다. 

### 세션

- HTTP는 기본적으로 상태 없는 프로토콜이지만 HTTP 쿠키는 세션을 만들어 서버 상태를 요청과 연결하도록 해준다. (ex: 쇼핑몰 바구니)



## HTTP 흐름

1. TCP 연결을 연다.

2. HTTP 메시지를 전송한다.

   ```
   GET / HTTP/1.1
   Host: developer.mozilla.org
   Accept-Language: fr
   ```

3. 서버에 의해 전송된 응답을 읽어들인다.

   ```
   HTTP/1.1 200 OK
   Date: Sat, 09 Oct 2010 14:28:02 GMT
   Server: Apache
   Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
   ETag: "51142bc1-7449-479b075b2891b"
   Accept-Ranges: bytes
   Content-Length: 29769
   Content-Type: text/html
   
   <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
   ```

4. 연결을 닫거나 다른 요청들을 위해 재사용한다. 



HTTP 파이프라이닝은 첫번째 응답을 완전히 수신할 때까지 기다리지 않고 여러 요청을 보내는 걸 가능하게 한다. 그러나 구현이 어려워 프레임 안에서 보다 활발한 다중 요청을 보내는  HTTP/2로 교체되고 있다.



## HTTP 메시지

### 요청

![HTTP 요청 메시지](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

- HTTP 메서드: GET, POST / OPTIONS, HEAD 
- 가져오려는 리소스의 경로
- HTTP 프로토콜의 버전
- 서버에 대한 추가 정보를 제공하는 선택적 헤더



### 응답

![HTTP 응답 메시지](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

- 프로토콜의 버전
- 상태 코드: 요청의 성공 여부와 그 이유
- 상태 메세지
- HTTP 헤더들



## HTTP 기반 API

- XMLHttpRequest API
- Fetch API
- 서버-전송 이벤트: 클라이언트는 EventSource 인터페이스를 사용하여, 연결을 맺고 이벤트 핸들러를 설정.  클라이언트 브라우저는 HTTP 스트림으로 도착한 메시지를 적절한 Event  객체로 자동 변환하여, 해당 이벤트 type에 대해 등록된 이벤트 핸들러로 전달하거나, 특정 유형의 이벤트가 설정되지 않은 경우에는 onmessage 이벤트 핸들러로 전달



## 결론

- HTTP: 사용 쉬운 확장 가능한 프로토콜
- 헤더를 쉽게 추가할 수 있는 능력을 지닌 클라이언트-서버 구조는 HTTP가 웹의 확장된 수용력과 함께 발전할 수 있게 함
- HTTP/2가 성능 향상을 위해 HTTP 메시지를 프레임 안으로 임베드하여 복잡함을 더하였지만 애플리케이션의 관점에서 볼 때 메시지의 구조는 이전과 동일하다.
- 세션의 흐름은 단순하며, 간단한 HTTP 메시지 모니터를 이용한 조사와 디버그를 가능하게 해준다.

