---
title: ":coffee: [Java] 이것이 자바다: 6장 클래스"
categories: Java
tags: [ Java ]
toc: true
---

# 객체 지향 프로그래밍

## 객체란?

- **자신의 속성**을 가지고 있고 다른 것과 **식별 가능**한 것을 말한다.
- 객체는 **속성과 동작**으로 구성되어 있다. 
- 자바는 이 속성과 동작들을 각각 **field와 method**라고 부른다.

- 객체 모델링(Object Modeling): 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
  - 현실 세계 객체의 속성과 동작을 추려내어 쇄프트웨어 객체의 필드와 메소드로 정의하는 과정



## 객체의 상호작용

- 현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 **상호작용**으로 이루어져 있다.
- 소프트웨어에서도 객체들은 각각 **독립적으로 존재**하고, 다른 객체와 서로 **상호작용**하면서 **동작**한다. 객체들 사이의 **상호작용 수단**은 **메소드**이다. 객체가 다른 객체의 기능을 **이용**하는 것이 메소드 **호출**이다.

```java
리턴값.전자계산기객체.메소드(매개값1, 매개값2..);
```

- **매개값**은 **메소드를 실행하기 위해 필요한 데이터**이다.

- **리턴값**은 메소드가 **실행하고 나서 호출한 곳으로 돌려주는 값**이다.

- 즉 객체의 상호작용은 객체 간의 메소드 호출을 의미하며, 매개값과 리턴값을 통해서 데이터를 주고받는다.



## 객체 간의 관계

- **집합 관계**: 하나는 **부품**이고 하나는 **완성품**에 해당한다(자동차 - 엔진, 타이어, 핸들)
- **사용 관계**: 객체 간의 **상호작용**을 말한다. 객체는 다른 객체의 **메소드를 호출**하여 원하는 결과를 얻어낸다. (사람 - 자동차 // 달린다, 멈춘다 메소드 호출)
- 상속 관계: 상위 객체(종류)를 기반으로 하위 객체(구체적인 사물)를 생성하는 관계를 말한다. (자동차 - 기계)



## 객체 지향 프로그래밍의 특징

### 캡슐화

- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용은 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 목적: 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 한다.
- 접근제한자: 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.



### 상속

- 상위 객체가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 사용할 수 있게 한다.
- 상위 객체를 재사용해서 하위 객체를 쉽고 빠르게 설계할 수 있도록 도와준다.
- 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만드므로 반복된 코드의 중복을 줄인다.
- 상위 객체의 수정으로 모든 하위 객체들의 수정효과를 가져와 유지보수 시간을 최소화한다.



### 다형성(Polymorphism)

-  같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.
- 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
- 다형성으로 인해 객체는 **부품화**가 가능해진다.
  - 자동차 설계 시 타이어 인터페이스 타입을 적용했다면 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관 없이 장착 가능하다. 자동차는 타이어 타입으로 한국 타이어와 금호 타이어를 사용하지만 각 타이어의 성능은 다르게 나온다.



# 객체와 클래스

- 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도(클래스)로 해당 객체를 만드는 작업이 필요하다. 클래스에는 필드와 메소드가 정의되어 있고, 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 부른다. 
- 객체 지향 프로그래밍 개발 단계
  - 클래스 설계
  - 설계된 클래스를 가지고 사용할 객체 생성
  - 생성된 객체 이용
- main() 메소드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야 한다.



# 클래스 선언

- 클래스이름.java로 소스 파일을 생성한다.
- 클래스를 선언한다. `public class 클래스이름 {}`
- 일반적으로 소스 파일 당 하나의 클래스를 선언하나, 두 개 이상의 클래스 선언도 가능하다.
- 두 개 이상의 클래스가 선언된 소스파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다. 즉, 소스파일은 클래스 선언을 담고 있는 저장 단위일 뿐, 클래스 자체가 아니다.

```java
// Car.java
public class Car {}
class Tire {}
```

- 파일 이름과 동일한 이름의 클래스 선언에만 Public 접근 제한자를 붙일 수 있다. (아닐 시 컴파일 에러!)
- 가급적 소스 파일 하나당 동일한 이름 클래스 하나를 선언하는 것이 좋다.



# 객체 생성과 클래스 변수

- 클래스 선언 후 컴파일(이클립스: 저장) 하면 객체를 생성할 설계도가 만들어진 것이다.

- 클래스로부터 객체 생성 방법: new 연산자 이용: `new 클래스();`
- new 연산자: 클래스로부터 객체를 생성시키는 연산자
- new 연산자로 생성된 객체는 heap 영역에 생성된다.
- 객체의 위치를 몯르면 객체를 사용할 수 없다. 따라서 new 연산자는  heap 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다. 이 주소를 참조타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.
- 클래스는 하나여도 new 연산자를 사용한 만큼 객체가 메모리에 생성된다. 이 객체들은 같은 클래스로부터 생성되었지만 각각의 객체는 자신만의 고유 데이터를 가지면서 메모리에서 활동하게 된다. 



## 클래스의 용도

- **라이브러리(API: Application Program Interface)용**
  - 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다.
- **실행용**
  - 실행 클래스는 프로그램의 진입점인 main() 메소드를 제공하는 역할을 한다.



- 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리고 하나가 실행클래스이다.
- 라이브러리인 동시에 실행 클래스로 만들 수도 있으나, 대부분의 객체 지향 프로그램은 라이브러리(부품 객체 및 완성 객체)와 실행 클래스가 분리되어 있다.

```java
// 라이브러리인 동시에 실행 클래스
public class Student {
    //라이브러리로서의 코드(필드, 생성자, 메소드)
    
    //실행하기 위한 코드
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student();
    }
}
```





# 클래스의 구성 멤버

클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 이 구성 멤버는 생략되거나 복수 개가 작성될 수 있다.

## 필드

- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.
- 필드를 변수라고 부르지 않는다.
  - 변수: 생성자와 메소드 내에서만 사용되고 생성자/메소드가 실행 종료되면 자동 소멸
  - 필드: 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재

## 생성자

- new 연산자로 호출되는 특별한 중괄호 블록이다.
- 객체 생성 시 초기화 담당: 필드를 초기화하거나, 메소드르 호출해서 객체를 사용할 준비를 한다.



## 메소드

- 객체의 동작에 해당하는 중괄호 블록
- 메소드를 호출하면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
- 필드를 읽고 수정할 뿐만 아니라 다른 객체를 생성해서 다양한 기능을 수행하기도 한다.
- **객체 간**의 **데이터 전달의 수단**으로 사용된다. 외부로부터 매개값을 받을 수도 있고, 실행 후 값을 리턴할 수도 있다.



# 필드

- 객체의 **고유 데이터**, 객체가 가져야 할 **부품**, 객체의 현재 **상태 데이터**를 저장하는 곳

```java
public class Car {
    // 고유 데이터
    String company;
    String model;
    String color;
    int maxSpeed;
    
    // 상태 데이터
    int speed;
    int rpm;
    
    // 부품
    Body body;
    Engine engine;
    Tire tire;
}
```

## 필드 선언

- 생성자와 메소드 블록 내부 이외의 클래스 블록 어디서든 존재할 수 있다.

- 생성자와 메소드 블록 내부에 선언된 것은 모두 로컬 변수가 된다.
- `타입 필드 [ = 초기값];`

- 타입: 필드에 저장할 데이터의 종류를 결정한다. 
- 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 **기본 초기값**으로 설정된다.

## 필드 사용

- 필드를 사용한다는 것은 **필드값을 읽고, 변경**하는 작업을 말한다.
- 클래스 **내부** 생성자나 메소드에서 사용할 경우 단순히 필드 이름을 읽고 변경하면 되지만, 클래스 **외부**에서 사용할 경우 우선적으로 클래스로부터 **객체를 생성**한 뒤 필드를 사용해야 한다. **필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문**이다.
- **도트 연산자**: **객체 접근 연산자**: 객체가 가지고 있는 필드나, 메소드를 사용하고자 할 때 사용

```java
class Person {
    //...
    void method() {
        // Car 객체 생성
        Car myCar = new Car();
        // 필드 사용
        myCar.speed = 60;
    }
}

class Car {
    // 필드
    int speed;
    // 생성자
    Car() {
        speed = 0;
    }
    // 메소드
    void method () {
        speed = 10;
    }
}
```



# 생성자

- new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화 담당
- 객체 초기화: 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 하는 것
- 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다.
- new 연산자에 의해 생성자가 성공적으로 실행되면 heap 영역에 객체가 생성되고 객체의 주소가 리턴된다. 리턴된 객체 주소는 클래스 타입 변수에 저장되어 객체의 접근할 때 사용한다.



## 기본 생성자

- 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다. 
- 생성자 선언을 생략했다면 컴파일러는 중괄호 블록이 비어있는 기본 생성자를 바이트 코드에 자동 추가한다. 
- 클래스가 public class로 선언되면 기본 생성자에도 public이 붙는다.
- 클래스가 명시적으로 선언한 생성자가 하나라도 있으면 컴파일러는 기본 생성자를 추가하지 않는다. 



## 생성자 선언

- 명시적으로 생성자를 선언하는 이유는 객체를 다양하게 초기화하기 위해서다. 
- 매개변수는 new 연산자로 생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할을 한다.

```java
클래스( 매개변수선언, ... ) {
    //객체의 초기화 코드
}
```

## 필드 초기화

### 초기화 방법

- 1) 필드를 선언할 때 초기값을 준다.
  - 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게 된다. (생성시)
- 2) 생성자에서 초기값을 준다.
  - 객체 생성 시점에서 외부에서 제공되는 다양한 값들로 초기화 되어야 할 때 사용
  - 아래 코드에서 이름과 주민번호 필드값은 **클래스를 작성할 때 초기값을 줄 수 없고** 객체 **생성 시점에 다양한 값**을 가져야 한다. 따라서 생성자의 매개값으로 값을 받아 초기화하는 것이 맞다.

```java
public class Korean {
  String nation = "대한민국";
  String name;
  String ssn;

  public Korean(String name, String ssn) {
    this.name = name;
    this.ssn = ssn;
  }
}

public class KoreanExample {
  public static void main(String[] args) {
    Korean k1 = new Korean("박자바", "012345 - 213214");
    Korean k2 = new Korean("김자바", "986043 - 542384");
    System.out.println(k1.name + " : " + k1.ssn);
    System.out.println(k2.name + " : " + k2.ssn);
  }
}
```

- 관례적으로 필드와 동일한 이름을 갖는 매개 변수를 사용한다, 이 경우 필드와 매개변수 이름이 동일하기 때문에 생성자 내부에서 해당 필드에 접근할 수 없다. 동일한 이름의 매개 변수가 사용 우선순위가 높기 때문이다. 이를 해결하기 위해서는 필드 앞에 `this`를 붙이면 된다. `this`는 객체 자신의 참조이다.
- 중요한 몇 개 필드만 매개변수를 통해 초기화되고 나머지 필드들은 필드 선언 시에 초기화하거나 생성자 내부에서 임의의 값 또는 계산된 값으로 초기화하거나, 객체 생성 후에 필드값을 별도로 저장한다.



## 생성자 오버로딩(Overloading)

- 자바는 상황에 맞게 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공한다.

- 매개 변수를 달리 하는 생성자를 여러개 선언하는 것을 말한다. 

```java
public class Car {
    Car(){}
    Car(String model){ this.model = model; }
    Car(String model, String color){ 
    	this.model = model;
        this.color = color;
    }
    Car(String model, String color, int maxSpeed){
        this.model = model;
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}
```

```java
Car car1 = new Car();
Car car2 = new Car("그랜저");
Car car3 = new Car("그랜저", "흰색");
Car car4 = new Car("그랜저", "흰색", "300");
```



## 다른 생성자 호출(`this()`)

- 생성자 오버로딩이 많아질 경우 생성자 간의 **중복된 코드**가 발생할 수 있따.
- 필드 **초기화 내용은 한 생성자에만 집중적으로 작성**하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
- `this()`는 반드시 생성자의 첫줄에서만 허용된다. 

```java
public class Car {
  String company = "현대자동차";
  String model;
  String color;
  int maxSpeed;

  Car() {}

  Car(String model) {
    this(model, "은색", 250);
  }

  Car(String model, String color) {
    this(model, color, 250);
  }

  Car(String model, String color, int maxSpeed) {
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
  }
}

```



# 메소드

- 객체의 동작에 해당하는 중괄호 블록
- 메소드는 필드를 읽고 수정하는 기능뿐만 아니라 다른 객체를 생성해서 다양한 기능을 수행한다.
- 외부로부터 매개값을 받을 수도 있고, 실행 후 값을 리턴할 수도 있다.



## 메소드 선언

- 메소드 시그너처: 메소드 선언부: 리턴타입 + 메소드 이름 + 매개변수 선언

### 리턴 타입

- 리턴값이 있는 메소드
  - 실행 후 결과를 호출한 곳에 넘겨줄 경우 리턴값이 있어야 한다.
  - 리턴값이 있으면 저장할 변수가 필요하다. 
  - 리턴값이 중요하지 않고, 메소드 실행이 중요할 경우 반드시 변수에 저장할 필요는 없다.
  - `double result = divide( 10, 20 );`
- 리턴값이 없는 메소드 
  - ex) `powerOn()`: 전원만 키면 된다.



### 매개 변수 선언

- 매개변수가 필요한 경우: `powerOn()`
- 매개변수가 필요 없는 경우: `divide()`



### 매개 변수의 수를 모를 경우

- 1) 매개 변수를 배열 타입으로 선언한다.
  - 문제점: 메소드를 호출하기 전에 배열을 생성해야 하는 불편함

```java
//선언
int sum1(int[] values) {}

// 호출
int[] values = {1, 2, 3}
int[] result = sum(values);
int result = sum1(new int[] {1, 2, 3, 4, 5});
```

- 2) 매개변수를 `...`를 사용해서 선언한다.
  - 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
  - 메소드 호출 시 리스트로 나열해준다.
  - 배열 타입이므로 배열을 직접 매개값으로 사용해도 된다. 

```java
package com.monica.thisisjava06;

public class Computer {
  int sum1(int[] values) {
    int sum = 0;
    for (int i = 0; i < values.length; i++) {
      sum += values[i];
    }
    return sum;
  }
  
  int sum2(int... values) {
    int sum = 0;
    for(int i = 0; i < values.length; i++) {
      sum += values[i];
    }
    return sum;
  }
}


package com.monica.thisisjava06;

public class ComputerExample {
  public static void main(String[] args) {
    Computer myCom = new Computer();
    int[] values1 = {1, 2, 3};
    System.out.println(myCom.sum1(values1));
    System.out.println(myCom.sum1(new int[] {1, 2, 3, 4, 5}));
    System.out.println(myCom.sum2(1, 2, 3));
    System.out.println(myCom.sum2(1, 2, 3, 4, 5));
  }
}
```





## 리턴문

### 리턴값이 있는 메소드

- return문이 실행되면 메소드는 즉시 종료된다.
- return문의 리턴값은 리턴 타입이거나 **리턴 타입으로 변환될 수 있어야 한다.** 
- ex) 리턴타입이 Int인 메소드에서 byte, short, int 타입의 값이 리턴되어도 상관 없다. byte와 short는 자동 타입변환되어 리턴되기 때문이다.
- 리턴문 이후에 실행문이 오면 unreachable 컴파일 오류가 발생한다.



## 리턴값이 없는 메소드

- 리턴값이 없는 메소드여도  return문을 사용할 수 있다. `return;`은 메소드 실행을 강제 종료시킨다.

```java
public class CarExample {
  public static void main(String[] args) {
    // 객체 생성
    Car myCar = new Car();
    myCar.setGas(5);
    
    boolean gasState = myCar.isLeftGas();
    if(gasState) {
      System.out.println("출발합니다.");
      myCar.run();
    }
    
    if(myCar.isLeftGas()) {
      System.out.println("gas를 주입할 필요가 없습니다.");
    } else {
      System.out.println("gas를 주입하세요.");
    }

  }
}
```

```java
package com.monica.thisisjava06;

public class Car {
  // 필드
  int gas;  
    
  void setGas(int gas) {
    this.gas = gas;
  }
    
  boolean isLeftGas() {
    if(gas == 0) {
      System.out.println("gas가 없습니다.");
      return false;
    } 
    System.out.println("gas가 있습니다.");
    return true;
  }
  
  void run() {
    while (true) {
      if (gas > 0) {
        System.out.println("달립니다. (gas잔량: " + gas + ")");
        gas -= 1;
      } else {
        System.out.println("멈춥니다. (gas잔량: " + gas + ")");
        return;
      }
    }
  }
}
```

