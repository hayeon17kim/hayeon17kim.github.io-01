---
title: "✍ 200814_TIL: [Java] String, "
categories: TIL
tags: [ TIL ]
toc: true
---



# java.lang.String

- 지금은 char 배열로 이해하라.

- JDK9부터 byte 배열로 바뀌었다. 순수한 ISO~로 되어있다면 1바이트로. 아니면 2바이트로. 

- char 배열은 영어든 한국어든 무조건 UTF-16으로 저장. 각각의 한 칸이 2바이트임.

  - 영어권애들이 싫어함

  => byte 배열

  - String UTF-16. 00다 떼버리고 무조건 1바이트.
  - 그러나 한글이 한 자로만 포함되어 있다면 2바이트

- hash값을 저장하기 위한 변수와 char배열. 이 두개가 인스턴스 변수. new String()하면 byte 배열고 ㅏint값을 넣을 변수. 이 최소 두개가 생김. 이 인스턴스가 어느 클래스의 정보인지 부가적인 정보 같이. 

- 같은 문자열이 있는지 검사하지 않고 무조건 저장

## 문자열 리터럴

- **문자열 상수풀(String constant pool)** 메모리 영역에 **String 인스턴스를 생성** 
- 내용물이 같으면 기존 인스턴스 주소를 리턴
- 메모리 절약을 위해 **중복 데이터를 갖는 인스턴스 생성하지 않는다**.
- JVM이 끝날 때까지 **메모리에 유지**됨.

    // 문자열 리터럴
    // - string constant pool 메모리 영역에 String 인스턴스를 생성한다.
    // - 내용물이 같으면 기존 인스턴스의 주소를 리턴한다.
    // - 즉 메모리 절약을 위해 중복 데이터를 갖는 인스턴스를 생성하지 않는다.
    // - JVM이 끝날 때까지 메모리에 유지된다.
    //
- 인터페이스당, 클래스당 하나 있다.
- 컴파일러가 자동으로 new String() 을 해서 스트링 인스턴스를 만드는데, 이때 인스턴스가 힙에 생성되는 게 아니라 상수풀에 저장된다.
- 같은 문자열이 있는지 검사하고 있다면 기존 주소를 리턴

### String 인스턴스를 상수풀에 생성하기: intern()

```java
    // intern()
    // - 지정된 String 객체를 상수풀에서 찾는다.
    // - 있으면 그 String 객체의 주소를 리턴한다.
    // - 없으면 상수풀에 String 객체를 생성한 후 그 주소를 리턴한다.
    String s2 = s1.intern();
    String s3 = "Hello";

    System.out.println(s1 == s2);
    System.out.println(s2 == s3);
```



###  String 인스터스에 있는 값을 비교하기 : equals()

- Object에서 상속 받은 equasl()를 오버라이딩하였다.
- 문자열이 같은지 비교한다.

#### equalsIgnoreCase()
- 대소문자 구분없이 문자열을 비교

### StringBuffer

- StringBuffer는 Object에서 상속 받은 equals()를 오버라이딩 하지 않았다.

> 오버라이딩? 상속받은 기능을 자신의 역할에 맞게끔 재정의하는 것

```java
    // StringBuffer 에 들어 있는 문자열을 비교하려면?
    // - StringBuffer에서 String을 꺼내 비교하라!
System.out.println(b1.toString().equals(b2.toString()));
    System.out.println(b1.toString());
    System.out.println(b2.toString());
```



### hashCode()

### toString()

    // Object.toString()은 "클래스명@해시값" 을 리턴한다.
    // String은 상속 받은 toString()을 오버라이딩 했다.
    // => this 주소를 그대로 리턴한다.


다형적 변수와 형변환

원래 들어 있는 게 (String)이면 바꿀 수 있다.

```java
Object obj = new String("Hello"); // 인스턴스 주소가 100이라 가정하자;

String x1 = (String) obj; // x1 <= 100
```


 Object obj = new String("Hello");

- 1. 서브인스턴스를 수퍼클래스에 담으면 수퍼클래스 메서드만 사용할 수 있다.

- 2. 만약 그 메서드 그런데 그 메서드 호출할 때는 실제 가리키는 인스턴스의 클래스부터 찾아 올라간다.    
- 컴파일러는 자식 객체의 주소라 할지라도 메서드는 레퍼런스 타입에 한정한다.
- 명시적 형변환 해주면.. 할 수 있음



```java
    Object obj = new String("Hello"); // 인스턴스 주소가 100이라 가정하자;

    String x1 = (String) obj; // x1 <= 100
    // obj에 대해 toString()을 호출할 때,
    // => 일단 obj의 클래스에 선언된 멤버(필드, 메서드)만 사용할 수 있다.
    // => 단 멤버는 실제 obj가 가리키는 클래스부터 찾아 올라간다.
    // => 위 예에서 obj가 가리키는 것은 String 이기 때문에 
    // => 이런 경우 toString()을 호출할 때 String 클래스에서부터 찾는다.
    // => String 클래스가 toString()을 오버라이딩 했기 때문에
    // 결국 이 오버라이딩 메서드를 호출할 것이다.
    String x2 = obj.toString(); // x2 <= 100

    System.out.println(x1 == x2);

    Object obj = new String("Hello");
    // obj가 String 객체를 가리키더라도
    // obj의 타입이 Object이기 때문에 Object에 선언한 멤버만 사용할 수 있다.
    // obj가 가리키는 원래 클래스의 메서들르 호출하고 싶다면
    // 다음과 같이 원래 타입으로 형변환하라.
    String str = ((String) obj).toLowerCase();
    System.out.println(str);
```



### mutable vs  immutable



- String : immutable 객체
  - 한번 객체가 생성되면 값을 변경할 수 없음
  - `replace()` , `concat()`: 새로운 문자열을 생성하여 그 주소를 리턴한다. 원본은 바뀌지 않는다.
  - 단점: 계속 새로 인스턴스를 만들어냄 => 힙에 쌓여서 가비지 됨 => 그래서 mutable인 StringBuffer 사용.
  
- StringBuffer: mmutable 객체



# Wrapper Class

- primitive datatype을 객체로 다루기 위해서 나온 문법



      void m1(Object value) {
        System.out.printf("value=%s\n", value);
      } // 모든 객체를 받을 수 있다.
      
      // 만약에 Wrapper 클래스가 없다면 다음과 같이
      // 정수를 받는 메서드와 부동소수점을 받는 메서드,
      // 논리값을 받는 메서드를 따로따로 정의해야 한다.
      // 이런 불편함을 없애기 위해 Wrapper클래스를 만든 것이다.
      // 즉 primitive type을 객체와 함께 다룰 수 있도록 만든 문법이다.
      void m2(long value) {
        System.out.printf("value=%s\n", value);
      } // byte, short, int, long, char
      void m3(double value) {
        System.out.printf("value=%s\n", value);
      } // float, double
      void m4(boolean value) {
        System.out.printf("value=%s\n", value);
      } // boolean
    
    // 래퍼 클래스의 주요 용도:
    // => primitive data type의 값을 객체로 주고 받을 때 사용한다.
    // => primitive data type의 값을 객체에 담아 전달하고 싶다면
    //    언제든 wrapper 클래스의 인스턴스를 만들면 된다.
    
        // 자바는 primitive data type의 값을 다룰 때 기본 연산자 외에  
        // 좀 더 다양한 방법으로 다루기 위해 
        // primitive data type에 대응하는 클래스를 제공한다.
```java
Byte c = 100; // 할당 시에는 4바이트 정수값이어도 메모리 넘지 않으면 허락
Byte b = new Byte((byte)100); // 생성자 파라미터로 넘겨줄 때는 명시
```



## 생성자 vs valueOf()

- new 명령어로 만들면 무조건 힙에 만들어진다.
- 같은 값이면 중복해서 인스턴스 만들지 않겠다. 기존에 있으면 그 객체의 주소를 리턴하겠다. 상수풀에 따로 관리(문자열 상소풀처럼 인트상수풀, 바이트상수풀)
- -128 ~ 127 범위의 수를 가지고 valueOf()를 호출하면 상수풀에



- 상수의 경우 JVM끝날 때까지 계속 남아있지만 Heap에 있으면 청소되니까..
- 자주 쓰는 건 상수풀에 넣고 나머지는 Heap에 넣자는 의도 





## auto-boxing / auto-unboxing

        // 자바는 primitive data type 값을 Wrapper 클래스의 인스턴스에 바로 할당할 수 있다.
        Integer obj = 100; // ==> Integer.valueOf(100)
    // => 내부적으로 Integer.valueOf(100)으로 바뀐다.
    // => 즉 int 값이 obj에 바로 저장되는 것이 아니라,
    // 내부적으로 Integer 객체가 생성되어 그 주소가 저장된다.
    // => 이렇게 int 값을 자동으로 Integer 객체로 만드는 것을
    // "오토박싱(auto-boxing)"이라 한다.
    // 자바는 Wrapper 객체의 값을 primitive data type 변수에 직접 할당할 수 있다.
    Integer obj = Integer.valueOf(300);
    int i = obj; // ==> obj.intValue()
    // obj에 저장된 것은 int 값이 아니라 Integer 객체의 주소인데 어떻게 가능한가?
    // => 내부적으로 obj.intValue()로 바뀐다.
    // => 즉 obj에 들어있는 인스턴스 주소가 i에 저장되는 것이 아니라,
    // obj 인스턴스에 들어 있는 값을 꺼내 i에 저장하는 것이다.
    // => 이렇게 Wrapper 객체 안에 들어 있는 값을 자동으로 꺼낸다고 해서
    // "오토언박싱"이라 부른다.
    // 자바가 wrapper 클래스를 이용하여 auto-boxing, auto-unboxing 기능을 제공함으로써
    // primitive data type 또는 클래스의 인스턴스 구분없이 값을 편리하게 저장할 수 있게 되었다.
    Object obj;
    obj = member; // 다형적 변수 문법에 따라 상위 클래스의 레퍼런스에 저장할 수 있다.
    obj = str; // 다형적 변수 문법에 따라 상위 클래스의 레퍼런스에 저장할 수 있다.
    obj = i; // auto-boxing 규칙에 따라 Integer.valueOf(i) 문장으로 변환한다.
    
    Integer obj2 = (Integer) obj;
    
    System.out.println(i);
    System.out.println(obj);


# 컬렉션 클래스

## ArrayList

 ArrayList가 관리하는 것은 인스턴스의 주소 목록이다.

인스턴스 주소 자체는 관리할 수 없다. 그건 jvm이 하는 일. 우리가 관리하는 것은 인스턴스의 주소일 뿐이다. 