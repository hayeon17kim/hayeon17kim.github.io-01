basic ex01

## 컴파일 및 실행 방법

```bash
// 1. 컴파일
$ javac -d bin/main -encoding UTF-8 src/main/java/com/eomcs/basic/ex01/Exam0110.java

// 2. 실행
$ java -cp bin/main com.eomcs.basic.ex01.Exam0110
```



## 클래스 블록과 컴파일

- 자바 컴파일러는 **클래스 블록 단위**로 컴파일을 수행한다.
- 

```java
public class Exam0120 {
  class A {}
  class B {}
  class C {}
}
// 컴파일 결과
// Exam120$A.class 
// Exam120$B.class 
// Exam120$C.class 
```



## 클래스 이름과 소스 파일 이름

- 공개 클래스: 소스 파일명이 클래스명과 같아야 한다. 다르면 컴파일 오류!
- 비공개 클래스: 클래스명과 소스 파일명이 일치하지 않아도 된다.

```java
// Exam0210 소스파일
package com.monica.basic.ex01;
// 다음과 같이 클래스명과 소스 파일명이 다르더라도 괜찮다.
class Exam2_1x {}
```

- 그러나 소스코드의 관리를 쉽게 하기 위해 보통 한 파일에 한 클래스를 두고, 클래스 이름과 파일명을 같게 한다.



## 소스파일의 인코딩 지정하기

- 소스파일의 인코딩 문자집합을 지정하지 않으면, **운영체제의 기본 문자집합**으로 저장되어 있다고 간주한다.
- 소스파일의 인코딩 문자집합이 운영체제의 기본 문자표(character set)와 다르다면, 컴파일 오류가 발생한다.
- 컴파일 옵션: `javac -encoding [문자집합] [소스파일명]`



## main() 메서드

- JVM을 통해 클래스를 실행하면, JVM은 그 클래스에서 main() 메서드를 찾아 실행한다. main() 메서드가 없으면 실행 오류가 발생한다.

## JVM이 클래스를 실행하는 과정

1. 실행할 클래스 파일을 CLASSPATH에 등록된 디렉토리 경로에서 찾는다.
2. 클래스 파일이 유효한 바이트코드(bytecode) 인지 검사한다.
3. 메모리에 바이트코드를 적재(load)한다.
4. `public static void main(String[] args) {}` 블록을 찾는다.
5. main() 블록에 들어 있는 코드를 실행한다.



# 주석

컴파일할 때 무시된다. 즉 .class파일이 존재하지 않는다.

##  여러줄 주석(traditional comment)

- 코드 중간에 삽입할 때 유용하다.
- C에서 사용하는 주석 문법과 같다.



## 한 줄 주석(end-of-line comment)

- C++에서 사용하는 주석 문법과 같다.



## Javadoc 주석

- javadoc에서 HTML 문서를 만들 때 사용하는 주석
- API 문서를 자동 생성할 때 사용한다.
- 클래스나 메서드, 변수 선언에 붙일 수 있다.

```java
/**
 * 클래스에 대한 설명
 * 
 * @author monicakim
 */
public class Exam0200 {
  /**
   * 변수에 대한 설명 변수 선언 앞에 설명을 붙여 놓으면 나중에 HTML 문서를 만들 때 추출할 수 있다.
   */
  static String message = "Hello world";

  /**
   * 메서드에 대한 설명 메서드에 대한 설명을 여기에 붙여 놓으면 나중에 HTML 문서를 만들 때 추출할 수 있다.
   * 
   * @param args 애플리케이션 아규먼트 값을 보관할 배열
   */
  public static void main(String[] args) {
    System.out.println(message);
  }
}
```

### 사용법

- Java Document 만들기: `javadoc.exe` 도구를 사용하여 자바 소스파일에서 Javadoc 주석을 추출하여 HTML 파일을 생성한다.
  - `-encoding [소스 파일의 문자집합]`
  - `-charset [생성될 HTML 파일의 문자 집합]`
  - `-d [생성될 파일을 놓아둘 디렉토리]`
  - `-sourcepath [자바 소스 경로] [자바 패키지]`
  - 예) `javadoc -encoding UTF-8 -charset UTF-8 -d javadoc -sourcepath src/main/java com.eomcs.basic.ex02`



## 애노테이션(annotation)

- 클래스, 변수(필드, 아규먼트, 로컬변수), 메서드 **선언**에 붙이는 주석이다.
- **컴파일러**나 **JVM**에서 사용할 주석이다.

- 작성 방법
  - `@애노테이션명(프로퍼티명=값, 프로퍼티명=값...)`
    - @Override
    - @SuppressWarnings(value="deprecation")
    - @SuperessWarnings(value={"unchecked", "deprecation"})



### 실습: @Override

- `@Override`는 수퍼 클래스에서 상속 받은 멤버를 재정의한다는 것을 컴파일러에게 알린다. 컴파일러는 오버라이딩 규칙을 준수하는지 검사한다. 

```java
@Override
public String toString() {
	return "Exam12";
}

//## 실습1 : 컴파일하기
//- $ javac -d bin/main -encoding UTF-8 src/main/java/com/eomcs/basic/ex02/Exam3.java
//- 오류없이 정상적으로 컴파일 된다.
//
//## 실습2 : @Override 애노테이션의 역할을 이해하기 I
//- toString() 메서드 이름을 toString2()로 변경한 다음에 컴파일 해 보라.
//
//## 실습3 : @Override 애노테이션의 역할을 이해하기 II
//- @Override 애노테이션을 주석으로 막은 다음에 다시 컴파일 해 보라.
//
```

- 오버라이딩 규칙을 어겼을 때는 컴파일 오류가 발생한다. (실습2)
- `@Override`을 사용하지 않을 경우 컴파일러는 오버라이딩을 정상적으로 했는지 검사하지 않기 때문에 오버라이딩 규칙을 어겼음에도 컴파일 오류가 발생하지 않는다. (실습3)



# 리터럴

- **자바 언어로 표현한 값**

## 정수 리터럴

### 기수법

```java
  //10진수 리터럴 
  //- 코드에서 일반적으로 정수 값을 표현할 때 사용한다.
  System.out.println(100);
  
  //8진수 리터럴
  //- 코드를 작성할 때 잘 사용하지 않는다.
  //- 0으로 시작해야 한다.
  System.out.println(0144);
  
  //2진수 리터럴
  //- 메모리의 상태를 직설적으로 보여주고 싶을 때 사용한다.
  //- 0b 또는 0B로 시작한다.
  System.out.println(0b1100100);
  System.out.println(0B1100100);
  
  //- 숫자 앞에 0이 있어도 된다.
  System.out.println(0b01100100);
  System.out.println(0B01100100);
  
  //16진수 리터럴
  //- 2진수를 간결하게 표현하기 위해 사용한다.
  //- 0x 또는 0X 로 시작한다.
  System.out.println(0x64);
  System.out.println(0X64);
  
  //- 숫자 앞에 0이 있어도 된다.
  System.out.println(0x064);
  System.out.println(0X064);

//결과: 전부 100
```



### 자릿수 표기

- 정수를 읽기 쉽도록 밑줄을 숫자 사이에 삽입할 수 있다. 
- 숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.

```java
    //## 10진수에 _ 문자를 삽입하기
    System.out.println(12783406);
    System.out.println(1278_3406);
    System.out.println(12_783_406);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(_12783406); 
    //System.out.println(12783406_);
    
    //## 8진수에 _ 문자를 삽입하기
    System.out.println(077);
    System.out.println(0_77);
    System.out.println(07_7);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(_077);
    //System.out.println(077_);

    //## 2진수에 _ 문자를 삽입하기
    System.out.println(0b1100100);
    System.out.println(0b110_0100);
    System.out.println(0b1_1_0_0_1_0_0);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(0b_1100100);
    //System.out.println(0b1100100_);

    //## 16진수에 _ 문자를 삽입하기
    System.out.println(0xffaa);
    System.out.println(0xff_aa);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(0x_ffaa);
    //System.out.println(0xffaa_);
```



### 메모리 크기에 따른 표기법

- 정수를 저장할 메모리의 크기를 지정할 수 있다.
#### 4바이트 정수
- 접미사 없이 그냥 숫자 표현하면 4바이트 크기의 메모리에 저장되는 정수를 표현한다. 
- 4바이트 메모리 크기를 초과하면 컴파일 오류가 발생한다.
  - `The literal 2147483648 of type int is out of range `



#### 8바이트 정수

- 4바이트 메모리를 벗어나는 정수 값을 표현할 때 사용한다.
- 숫자 뒤에 L 또는 l을 붙인다.



#### 4/8바이트 정수의 최대값과 최소값

```java
  //## 4바이트 또는 8바이트 정수의 최대값과 최소값
  //자바에서는 각 데이터 유형에 따라 최대/최소 값을 알아볼 수 있도록 특별한 명령을 제공한다.
  System.out.println(Integer.MAX_VALUE); // 4바이트로 표현할 수 있는 정수 최대값
  System.out.println(Integer.MIN_VALUE); // 4바이트로 표현할 수 있는 정수 최소값
  System.out.println(Long.MAX_VALUE); // 8바이트로 표현할 수 있는 정수 최대값 
  System.out.println(Long.MIN_VALUE); // 8바이트로 표현할 수 있는 정수 최소값
  
```



### 메모리에 저장하는 방법

- **컴퓨터**에서는 값을 저장할 때 **전기 신호(예: RAM)** 또는 **자기 신호(예: HDD)**로 저장한다.
- 값은 비트로 표현되고, 각 비트는 전기가 있거나 없는 두 상태로 표현한다.

- 비트의 두 가지 상태를 표현할 때 2진수의 0과 1을 사용하므로 **값을 메모리에 저장하려면 2진수로 표현할 수 있어야 한다**.
- 그림이나 사진(BITMAP), 음성(WAV), 색상(RGB)을 저장할 때도 2진수로 표현한다.



### 숫자를 2진수로 표현하는 방법

#### 부호-크기/절대값 (Sign-Magnitude)

- 부동소수점에서 가수부(significand or mantissa)를 저장할 때 사용
- 맨 왼쪽 1비트를 부호 비트로, 나머지 비트를 절대값으로 저장한다.

```java
//    8비트 = 1비트(부호) + 7비트(절대값)
//  예) +24 => |+24| = 24 ---> 0001 1000
//  예) -24 => |-24| = 24 ---> 1001 1000
```

- 단점
  - 두 개의 0(+0, -0)이 존재한다.
  - 양수와 음수를 더했을 때 옳지 않은 값이 나온다.
    - 4비트일 경우, 1 + -1 = 0001 + 1001 = 1010 = -2로, 계산 결과가 옳지 않다. 
  - **빼기를 처리하는 컴퓨팅 회로를 별도로 설계해야 하므로 하드웨어가 복잡해진다.**
- 장점
  - 이해하기 쉽다.
- 수의 범위: (2^7 + 1) ~ (2^7 - 1)

```Java
//- 수의 범위(8비트 기준): -127 ~ + 127
//   0111 1111 (127)
//   0111 1110 (126)
//   0111 1101 (125)
//      ...
//   0000 0001 (1)
//   0000 0000 (+0)
//   1000 0000 (-0)
//   1000 0001 (-1)
//      ...
//   1111 1101 (-125)
//   1111 1110 (-126)
//   1111 1111 (-127)
```

> 보수란? 두 수의 합이 진법의 밑수(N)가 되게 하는 수를 말한다. 예) 10진수 4의 10의 보수는 6, 10진수 2의 10의 보수는 8이다. 
> 보수는 컴퓨터에서 음의 정수를 표현하기 위해서 고안되었다. 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 **뺄셈**은 덧셈으로 형식을 변환하여 계산해야 한다. 즉 **컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산**한다.

> 2진수 표현
>
> - 양수: 그냥 2진수로 변환한 수 사용 ( 방법에 상관 없음 )
> - 음수: 방법에 따라 다르게 나옴

#### 1의 보수(One's Complement)

- 모든 비트를 반대 값으로 바꾼다.

```java
//- 모든 비트를 반대 값으로 바꾼다.
//  예) +24 => 0001 1000
//  예) -24 => 1110 0111
```

- 단점
  - **두 개의 0 (+0, -0)이 존재**한다.
  - **두 수를 더한 후 비트 크기를 초과한 1 값을 다시 맨 뒤에 더해야만 옳은 값**이 된다.

```java
//       0001(+1)
//       1110(-1)
//       --------
//       1111(-0) <--- 음수 0과 양수 0을 다뤄야 하는 것이 번거롭다.
//
//       0101(+5)
//       1100(-3)
//       --------
//     1 0001(1) <--- 옳지 않은 값.
//     +    1    <--- 4비트를 초과하는 값을 다시 맨 뒤에 더함.
//     ---------
//       0010(2) <--- 옳은 값!
```

- 수의 범위: (2^7 + 1) ~ (2^7 - 1)

```java
//- 수의 범위(8비트 기준): -127 ~ +127
//   0111 1111 (127)
//   0111 1110 (126)
//   0111 1101 (125)
//      ...
//   0000 0001 (1)
//   0000 0000 (+0)
//   1111 1111 (-0)
//   1111 1110 (-1)
//      ...
//   1000 0010 (-125)
//   1000 0001 (-126)
//   1000 0000 (-127)
```



#### 2의 보수(Two's complement)

- **자바에서 음수**를 저장하는 방법이다.
- **1의 보수의 문제점을 해결**하기 위해 등장한 방법이다.
  - 1의 보수로 저장된 음수 값을 더할 때마다 계산 결과에 1을 추가하는 번거로움을 없애기 위해 음수를 저장할 때 미리 1을 추가해 두는 방법
  - 1의 보수 + 1 => 2의 보수
- **음수 0을 없앰**으로서 **-128까지 표현할 수 있다**.
- 컴퓨터에서 음수를 메모리에 저장할 때는 양수와 음수를 더할 때 정상적인 값이 나오도록 2의 보수 방법으로 음수를 저장한다. 



##### 2의 보수 만드는 방법

1. 모든 비트를 반대 값으로 만든 다음 1을 더한다.

   ```java
   //  예) 0010 1001(+41)
   //      1101 0110(1의 보수)
   //              1
   //      ---------
   //      1101 0111(-41)
   ```

2. 오른쪽에서부터 1을 찾고, 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.

   ```java
   //    예) 0010 1001(41) => 1101 0111(-41)
   //                ^                ^
   //    예) 0010 1100(44) => 1101 0100(-44)
   //              ^                ^
   ```

3. 2^n(8비트일 경우 2^8)에서 음수 값만큼 뺀다.

   ```java
   //  - 2^n(8비트일 경우 2^8 = 256)에서 음수 값 만큼 뺀다.
   //    예) -41 => 256 - 41 = 215 = 1101 0111
   //    예) -44 => 256 - 44 = 212 = 1101 0100
   ```

- 장점
  - **양수와 음수의 덧셈이 가능**하다.
  - **음수 0이 없다.** 0에 대한 표현이 한 가지이다.

- 수의 범위

```java
//- 수의 범위(8비트 기준): -128 ~ +127
//   0111 1111 (127)
//   0111 1110 (126)
//   0111 1101 (125)
//      ...
//   0000 0010 (2)
//   0000 0001 (1)
//   0000 0000 (+0)
//   1111 1111 (-1)
//   1111 1110 (-2)
//      ...
//   1000 0011 (-125)
//   1000 0010 (-126)
//   1000 0001 (-127)
//   1000 0000 (-128)
```

- 실습: -10을 2진수로 표현하기

```java
//## -10을 2진수로 표현하기
//1) 10을 2진수로 바꾼다.
//   +10 => 0000 1010
//2) 1의 보수로 바꾼다. 즉 0은 1로 1은 0으로 바꾼다.
//   0000 1010 => 1111 0101
//3) 2의 보수로 바꾼다. 1의 보수에 1을 더한다.
//     1111 0101
//   + 0000 0001
//     ---------
//     1111 0110
//
//## 음수가 2의 보수로 저장되었을 때 이점
//- 덧셈으로 빼기를 수행할 수 있기 때문이다.
//  예) 10 - 7 = 10 + (-7) = 3
//      10      => 0000 1010
//      7       => 0000 0111
//      -7      => 1111 1000 + 1 = 1111 1001
//
//      0000 1010 (10)
//    + 1111 1001 (-7)
//    -----------------
//    1 0000 0011 (3)  => 8비트를 넘어가는 값은 버린다.
//
```

#### K-초과(Excess-K)

- 부동 소수점의 지수부(exponent)를 저장할 때 사용한다.
- 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation)이라고도 한다.
- K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용한다.
  - 표현하려는 값 + 초과 값(K) = 결과
- 바이어스 값(K)을 구하는 공식
  - K = 2^(비트수 - 1)

```java
//  예) 8비트일 경우 ---> K = 2^(8 - 1) = 2^7 = 128, 결과 = 128 + 값
//   1111 1111 = 128 + 127
//   1111 1110 = 128 + 126
//   1111 1101 = 128 + 125
//      ...
//   1000 0001 = 128 + 1
//   1000 0000 = 128 + 0
//   0111 1111 = 128 + (-1)
//      ...
//   0000 0010 = 128 + (-126)
//   0000 0001 = 128 + (-127)
//   0000 0000 = 128 + (-128)
```

- IEEE 부동소수점 표준에서 사용하는 공식
  - K = 2^(비트수 - 1) - 1

```java
//  예) 8비트일 경우 ---> K = 2^7 - 1 = 127, 결과 = 127 + 값
//   1111 1111 = 127 + 128
//   1111 1110 = 127 + 127
//   1111 1101 = 127 + 126
//   1111 1100 = 127 + 125
//      ...
//   1000 0000 = 127 + 1
//   0111 1111 = 127 + 0
//   0111 1110 = 127 + (-1)
//      ...
//   0000 0010 = 127 + (-125)
//   0000 0001 = 127 + (-126)
//   0000 0000 = 127 + (-127)
```

- 바이어스 방식으로 데이터를 저장할 때의 이점
  - 모든 비트가 0일 때 최소 값을 가지고, 모든 비트가 1일 때 최대 값을 갖는다.
  - 이런 이유로 작은 값에서 큰 값으로 정렬되는 결과를 낳는다. 모든 비트가 정렬된 상태이기 때문에 부동소수점이든 정수이든 상관 없다. 
  - '부호-크기', '1의 보수', '2의 보수'와 같은 방법으로 값을 표현할 경우, 비트들이 순차적으로 정렬되지 않는다.

