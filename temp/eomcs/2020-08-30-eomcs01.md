basic ex01

## 컴파일 및 실행 방법

```bash
// 1. 컴파일
$ javac -d bin/main -encoding UTF-8 src/main/java/com/eomcs/basic/ex01/Exam0110.java

// 2. 실행
$ java -cp bin/main com.eomcs.basic.ex01.Exam0110
```



## 클래스 블록과 컴파일

- 자바 컴파일러는 **클래스 블록 단위**로 컴파일을 수행한다.
- 

```java
public class Exam0120 {
  class A {}
  class B {}
  class C {}
}
// 컴파일 결과
// Exam120$A.class 
// Exam120$B.class 
// Exam120$C.class 
```



## 클래스 이름과 소스 파일 이름

- 공개 클래스: 소스 파일명이 클래스명과 같아야 한다. 다르면 컴파일 오류!
- 비공개 클래스: 클래스명과 소스 파일명이 일치하지 않아도 된다.

```java
// Exam0210 소스파일
package com.monica.basic.ex01;
// 다음과 같이 클래스명과 소스 파일명이 다르더라도 괜찮다.
class Exam2_1x {}
```

- 그러나 소스코드의 관리를 쉽게 하기 위해 보통 한 파일에 한 클래스를 두고, 클래스 이름과 파일명을 같게 한다.



## 소스파일의 인코딩 지정하기

- 소스파일의 인코딩 문자집합을 지정하지 않으면, **운영체제의 기본 문자집합**으로 저장되어 있다고 간주한다.
- 소스파일의 인코딩 문자집합이 운영체제의 기본 문자표(character set)와 다르다면, 컴파일 오류가 발생한다.
- 컴파일 옵션: `javac -encoding [문자집합] [소스파일명]`



## main() 메서드

- JVM을 통해 클래스를 실행하면, JVM은 그 클래스에서 main() 메서드를 찾아 실행한다. main() 메서드가 없으면 실행 오류가 발생한다.

## JVM이 클래스를 실행하는 과정

1. 실행할 클래스 파일을 CLASSPATH에 등록된 디렉토리 경로에서 찾는다.
2. 클래스 파일이 유효한 바이트코드(bytecode) 인지 검사한다.
3. 메모리에 바이트코드를 적재(load)한다.
4. `public static void main(String[] args) {}` 블록을 찾는다.
5. main() 블록에 들어 있는 코드를 실행한다.



# 주석

컴파일할 때 무시된다. 즉 .class파일이 존재하지 않는다.

##  여러줄 주석(traditional comment)

- 코드 중간에 삽입할 때 유용하다.
- C에서 사용하는 주석 문법과 같다.



## 한 줄 주석(end-of-line comment)

- C++에서 사용하는 주석 문법과 같다.



## Javadoc 주석

- javadoc에서 HTML 문서를 만들 때 사용하는 주석
- API 문서를 자동 생성할 때 사용한다.
- 클래스나 메서드, 변수 선언에 붙일 수 있다.

```java
/**
 * 클래스에 대한 설명
 * 
 * @author monicakim
 */
public class Exam0200 {
  /**
   * 변수에 대한 설명 변수 선언 앞에 설명을 붙여 놓으면 나중에 HTML 문서를 만들 때 추출할 수 있다.
   */
  static String message = "Hello world";

  /**
   * 메서드에 대한 설명 메서드에 대한 설명을 여기에 붙여 놓으면 나중에 HTML 문서를 만들 때 추출할 수 있다.
   * 
   * @param args 애플리케이션 아규먼트 값을 보관할 배열
   */
  public static void main(String[] args) {
    System.out.println(message);
  }
}
```

### 사용법

- Java Document 만들기: `javadoc.exe` 도구를 사용하여 자바 소스파일에서 Javadoc 주석을 추출하여 HTML 파일을 생성한다.
  - `-encoding [소스 파일의 문자집합]`
  - `-charset [생성될 HTML 파일의 문자 집합]`
  - `-d [생성될 파일을 놓아둘 디렉토리]`
  - `-sourcepath [자바 소스 경로] [자바 패키지]`
  - 예) `javadoc -encoding UTF-8 -charset UTF-8 -d javadoc -sourcepath src/main/java com.eomcs.basic.ex02`



## 애노테이션(annotation)

- 클래스, 변수(필드, 아규먼트, 로컬변수), 메서드 **선언**에 붙이는 주석이다.
- **컴파일러**나 **JVM**에서 사용할 주석이다.

- 작성 방법
  - `@애노테이션명(프로퍼티명=값, 프로퍼티명=값...)`
    - @Override
    - @SuppressWarnings(value="deprecation")
    - @SuperessWarnings(value={"unchecked", "deprecation"})



### 실습: @Override

- `@Override`는 수퍼 클래스에서 상속 받은 멤버를 재정의한다는 것을 컴파일러에게 알린다. 컴파일러는 오버라이딩 규칙을 준수하는지 검사한다. 

```java
@Override
public String toString() {
	return "Exam12";
}

//## 실습1 : 컴파일하기
//- $ javac -d bin/main -encoding UTF-8 src/main/java/com/eomcs/basic/ex02/Exam3.java
//- 오류없이 정상적으로 컴파일 된다.
//
//## 실습2 : @Override 애노테이션의 역할을 이해하기 I
//- toString() 메서드 이름을 toString2()로 변경한 다음에 컴파일 해 보라.
//
//## 실습3 : @Override 애노테이션의 역할을 이해하기 II
//- @Override 애노테이션을 주석으로 막은 다음에 다시 컴파일 해 보라.
//
```

- 오버라이딩 규칙을 어겼을 때는 컴파일 오류가 발생한다. (실습2)
- `@Override`을 사용하지 않을 경우 컴파일러는 오버라이딩을 정상적으로 했는지 검사하지 않기 때문에 오버라이딩 규칙을 어겼음에도 컴파일 오류가 발생하지 않는다. (실습3)



# 리터럴

- **자바 언어로 표현한 값**

## 정수 리터럴

### 기수법

```java
  //10진수 리터럴 
  //- 코드에서 일반적으로 정수 값을 표현할 때 사용한다.
  System.out.println(100);
  
  //8진수 리터럴
  //- 코드를 작성할 때 잘 사용하지 않는다.
  //- 0으로 시작해야 한다.
  System.out.println(0144);
  
  //2진수 리터럴
  //- 메모리의 상태를 직설적으로 보여주고 싶을 때 사용한다.
  //- 0b 또는 0B로 시작한다.
  System.out.println(0b1100100);
  System.out.println(0B1100100);
  
  //- 숫자 앞에 0이 있어도 된다.
  System.out.println(0b01100100);
  System.out.println(0B01100100);
  
  //16진수 리터럴
  //- 2진수를 간결하게 표현하기 위해 사용한다.
  //- 0x 또는 0X 로 시작한다.
  System.out.println(0x64);
  System.out.println(0X64);
  
  //- 숫자 앞에 0이 있어도 된다.
  System.out.println(0x064);
  System.out.println(0X064);

//결과: 전부 100
```



### 자릿수 표기

- 정수를 읽기 쉽도록 밑줄을 숫자 사이에 삽입할 수 있다. 
- 숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.

```java
    //## 10진수에 _ 문자를 삽입하기
    System.out.println(12783406);
    System.out.println(1278_3406);
    System.out.println(12_783_406);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(_12783406); 
    //System.out.println(12783406_);
    
    //## 8진수에 _ 문자를 삽입하기
    System.out.println(077);
    System.out.println(0_77);
    System.out.println(07_7);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(_077);
    //System.out.println(077_);

    //## 2진수에 _ 문자를 삽입하기
    System.out.println(0b1100100);
    System.out.println(0b110_0100);
    System.out.println(0b1_1_0_0_1_0_0);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(0b_1100100);
    //System.out.println(0b1100100_);

    //## 16진수에 _ 문자를 삽입하기
    System.out.println(0xffaa);
    System.out.println(0xff_aa);

    //숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.
    //System.out.println(0x_ffaa);
    //System.out.println(0xffaa_);
```



### 메모리 크기에 따른 표기법

- 정수를 저장할 메모리의 크기를 지정할 수 있다.
#### 4바이트 정수
- 접미사 없이 그냥 숫자 표현하면 4바이트 크기의 메모리에 저장되는 정수를 표현한다. 
- 4바이트 메모리 크기를 초과하면 컴파일 오류가 발생한다.
  - `The literal 2147483648 of type int is out of range `



#### 8바이트 정수

- 4바이트 메모리를 벗어나는 정수 값을 표현할 때 사용한다.
- 숫자 뒤에 L 또는 l을 붙인다.



#### 4/8바이트 정수의 최대값과 최소값

```java
  //## 4바이트 또는 8바이트 정수의 최대값과 최소값
  //자바에서는 각 데이터 유형에 따라 최대/최소 값을 알아볼 수 있도록 특별한 명령을 제공한다.
  System.out.println(Integer.MAX_VALUE); // 4바이트로 표현할 수 있는 정수 최대값
  System.out.println(Integer.MIN_VALUE); // 4바이트로 표현할 수 있는 정수 최소값
  System.out.println(Long.MAX_VALUE); // 8바이트로 표현할 수 있는 정수 최대값 
  System.out.println(Long.MIN_VALUE); // 8바이트로 표현할 수 있는 정수 최소값
  
```



### 메모리에 저장하는 방법

- **컴퓨터**에서는 값을 저장할 때 **전기 신호(예: RAM)** 또는 **자기 신호(예: HDD)**로 저장한다.
- 값은 비트로 표현되고, 각 비트는 전기가 있거나 없는 두 상태로 표현한다.

- 비트의 두 가지 상태를 표현할 때 2진수의 0과 1을 사용하므로 **값을 메모리에 저장하려면 2진수로 표현할 수 있어야 한다**.
- 그림이나 사진(BITMAP), 음성(WAV), 색상(RGB)을 저장할 때도 2진수로 표현한다.



### 숫자를 2진수로 표현하는 방법

#### 부호-크기/절대값 (Sign-Magnitude)

- 부동소수점에서 가수부(significand or mantissa)를 저장할 때 사용
- 맨 왼쪽 1비트를 부호 비트로, 나머지 비트를 절대값으로 저장한다.

```java
//    8비트 = 1비트(부호) + 7비트(절대값)
//  예) +24 => |+24| = 24 ---> 0001 1000
//  예) -24 => |-24| = 24 ---> 1001 1000
```

- 단점
  - 두 개의 0(+0, -0)이 존재한다.
  - 양수와 음수를 더했을 때 옳지 않은 값이 나온다.
    - 4비트일 경우, 1 + -1 = 0001 + 1001 = 1010 = -2로, 계산 결과가 옳지 않다. 
  - **빼기를 처리하는 컴퓨팅 회로를 별도로 설계해야 하므로 하드웨어가 복잡해진다.**
- 장점
  - 이해하기 쉽다.
- 수의 범위: (2^7 + 1) ~ (2^7 - 1)

```Java
//- 수의 범위(8비트 기준): -127 ~ + 127
//   0111 1111 (127)
//   0111 1110 (126)
//   0111 1101 (125)
//      ...
//   0000 0001 (1)
//   0000 0000 (+0)
//   1000 0000 (-0)
//   1000 0001 (-1)
//      ...
//   1111 1101 (-125)
//   1111 1110 (-126)
//   1111 1111 (-127)
```

> 보수란? 두 수의 합이 진법의 밑수(N)가 되게 하는 수를 말한다. 예) 10진수 4의 10의 보수는 6, 10진수 2의 10의 보수는 8이다. 
> 보수는 컴퓨터에서 음의 정수를 표현하기 위해서 고안되었다. 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 **뺄셈**은 덧셈으로 형식을 변환하여 계산해야 한다. 즉 **컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산**한다.

> 2진수 표현
>
> - 양수: 그냥 2진수로 변환한 수 사용 ( 방법에 상관 없음 )
> - 음수: 방법에 따라 다르게 나옴

#### 1의 보수(One's Complement)

- 모든 비트를 반대 값으로 바꾼다.

```java
//- 모든 비트를 반대 값으로 바꾼다.
//  예) +24 => 0001 1000
//  예) -24 => 1110 0111
```

- 단점
  - **두 개의 0 (+0, -0)이 존재**한다.
  - **두 수를 더한 후 비트 크기를 초과한 1 값을 다시 맨 뒤에 더해야만 옳은 값**이 된다.

```java
//       0001(+1)
//       1110(-1)
//       --------
//       1111(-0) <--- 음수 0과 양수 0을 다뤄야 하는 것이 번거롭다.
//
//       0101(+5)
//       1100(-3)
//       --------
//     1 0001(1) <--- 옳지 않은 값.
//     +    1    <--- 4비트를 초과하는 값을 다시 맨 뒤에 더함.
//     ---------
//       0010(2) <--- 옳은 값!
```

- 수의 범위: (2^7 + 1) ~ (2^7 - 1)

```java
//- 수의 범위(8비트 기준): -127 ~ +127
//   0111 1111 (127)
//   0111 1110 (126)
//   0111 1101 (125)
//      ...
//   0000 0001 (1)
//   0000 0000 (+0)
//   1111 1111 (-0)
//   1111 1110 (-1)
//      ...
//   1000 0010 (-125)
//   1000 0001 (-126)
//   1000 0000 (-127)
```



#### 2의 보수(Two's complement)

- **자바에서 음수**를 저장하는 방법이다.
- **1의 보수의 문제점을 해결**하기 위해 등장한 방법이다.
  - 1의 보수로 저장된 음수 값을 더할 때마다 계산 결과에 1을 추가하는 번거로움을 없애기 위해 음수를 저장할 때 미리 1을 추가해 두는 방법
  - 1의 보수 + 1 => 2의 보수
- **음수 0을 없앰**으로서 **-128까지 표현할 수 있다**.
- 컴퓨터에서 음수를 메모리에 저장할 때는 양수와 음수를 더할 때 정상적인 값이 나오도록 2의 보수 방법으로 음수를 저장한다. 



##### 2의 보수 만드는 방법

1. 모든 비트를 반대 값으로 만든 다음 1을 더한다.

   ```java
   //  예) 0010 1001(+41)
   //      1101 0110(1의 보수)
   //              1
   //      ---------
   //      1101 0111(-41)
   ```

2. 오른쪽에서부터 1을 찾고, 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.

   ```java
   //    예) 0010 1001(41) => 1101 0111(-41)
   //                ^                ^
   //    예) 0010 1100(44) => 1101 0100(-44)
   //              ^                ^
   ```

3. 2^n(8비트일 경우 2^8)에서 음수 값만큼 뺀다.

   ```java
   //  - 2^n(8비트일 경우 2^8 = 256)에서 음수 값 만큼 뺀다.
   //    예) -41 => 256 - 41 = 215 = 1101 0111
   //    예) -44 => 256 - 44 = 212 = 1101 0100
   ```

- 장점
  - **양수와 음수의 덧셈이 가능**하다.
  - **음수 0이 없다.** 0에 대한 표현이 한 가지이다.

- 수의 범위

```java
//- 수의 범위(8비트 기준): -128 ~ +127
//   0111 1111 (127)
//   0111 1110 (126)
//   0111 1101 (125)
//      ...
//   0000 0010 (2)
//   0000 0001 (1)
//   0000 0000 (+0)
//   1111 1111 (-1)
//   1111 1110 (-2)
//      ...
//   1000 0011 (-125)
//   1000 0010 (-126)
//   1000 0001 (-127)
//   1000 0000 (-128)
```

- 실습: -10을 2진수로 표현하기

```java
//## -10을 2진수로 표현하기
//1) 10을 2진수로 바꾼다.
//   +10 => 0000 1010
//2) 1의 보수로 바꾼다. 즉 0은 1로 1은 0으로 바꾼다.
//   0000 1010 => 1111 0101
//3) 2의 보수로 바꾼다. 1의 보수에 1을 더한다.
//     1111 0101
//   + 0000 0001
//     ---------
//     1111 0110
//
//## 음수가 2의 보수로 저장되었을 때 이점
//- 덧셈으로 빼기를 수행할 수 있기 때문이다.
//  예) 10 - 7 = 10 + (-7) = 3
//      10      => 0000 1010
//      7       => 0000 0111
//      -7      => 1111 1000 + 1 = 1111 1001
//
//      0000 1010 (10)
//    + 1111 1001 (-7)
//    -----------------
//    1 0000 0011 (3)  => 8비트를 넘어가는 값은 버린다.
//
```

#### K-초과(Excess-K)

- 부동 소수점의 지수부(exponent)를 저장할 때 사용한다.
- 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation)이라고도 한다.
- K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용한다.
  - 표현하려는 값 + 초과 값(K) = 결과
- 바이어스 값(K)을 구하는 공식
  - K = 2^(비트수 - 1)

```java
//  예) 8비트일 경우 ---> K = 2^(8 - 1) = 2^7 = 128, 결과 = 128 + 값
//   1111 1111 = 128 + 127
//   1111 1110 = 128 + 126
//   1111 1101 = 128 + 125
//      ...
//   1000 0001 = 128 + 1
//   1000 0000 = 128 + 0
//   0111 1111 = 128 + (-1)
//      ...
//   0000 0010 = 128 + (-126)
//   0000 0001 = 128 + (-127)
//   0000 0000 = 128 + (-128)
```

- IEEE 부동소수점 표준에서 사용하는 공식
  - K = 2^(비트수 - 1) - 1

```java
//  예) 8비트일 경우 ---> K = 2^7 - 1 = 127, 결과 = 127 + 값
//   1111 1111 = 127 + 128
//   1111 1110 = 127 + 127
//   1111 1101 = 127 + 126
//   1111 1100 = 127 + 125
//      ...
//   1000 0000 = 127 + 1
//   0111 1111 = 127 + 0
//   0111 1110 = 127 + (-1)
//      ...
//   0000 0010 = 127 + (-125)
//   0000 0001 = 127 + (-126)
//   0000 0000 = 127 + (-127)
```

- 바이어스 방식으로 데이터를 저장할 때의 이점
  - 모든 비트가 0일 때 최소 값을 가지고, 모든 비트가 1일 때 최대 값을 갖는다.
  - 이런 이유로 작은 값에서 큰 값으로 정렬되는 결과를 낳는다. 모든 비트가 정렬된 상태이기 때문에 부동소수점이든 정수이든 상관 없다. 
  - '부호-크기', '1의 보수', '2의 보수'와 같은 방법으로 값을 표현할 경우, 비트들이 순차적으로 정렬되지 ㅇ않는다.



## 정수를 메모리에 저장하는 방법

1. sign magnitude: 맨 앞 비트로 음수 표시
2. 1's complement (1의 보수)
3. 2's complement (2의 보수)

- 음수는 2의 보수 방법으로 저장한다. 



## 부동소수점 리터럴

- 실수값을 부동소수점 방식으로 저장하려면 1과 0으로 변환한다.
- 자바는 부동소수점으로 저장할 때 전기전자기술자협회(IEEE)에서 개발한 IEEE 754 명세에 따라 2진수로 변환한다.

### 10진수 표기법: Exponential 기호 사용하기

- e 기호를 사용하면 소수점의 위치를 조정할 수 있다. 
- 소수점의 위치를 움직인다고 해서 부동소수점(floating point)라 부른다.
- 표기법: 숫자e지수 / 숫자E지수

```java
System.out.println(0.0314e2); // 0.0314 * 10의2승 = 3.14
System.out.println(0.314e1); // 0.314 * 10의1승 = 3.14
System.out.println(31.4e-1); // 31.4 * 10의-1승 = 3.14
System.out.println(314.e-2); // 314 * 10의-2승 = 3.14
```



### 메모리의 크기에 따른 표기법

- 8바이트 크기의 부동소수점
  - 숫자 맨 뒤에 d 또는 D를 붙인다 (생락 가능)
- 4바이트 크기의 부동소수점
  - 숫자 맨 뒤에 f 또는 F를 붙인다.

### 유효자릿수

- 정수처럼 메모리 크기에 따라 표현할 수 있는 부동소수점 범위가 다르다.
- 단 IEEE 754 명세에 따라 2진수로 변환되기 때문에 정확하게 '소수점 이상 얼마까지 소수점 이하 얼마까지' 식으로 정의할 수 없다.
- 대신 '유효자릿수'라는 방식으로 대략적으로 값의 범위를 표현한다.

- 4바이트 부동소수점 유효자리수
  - 소수점을 뺀 후 7자리 숫자까지는 거의 정상적으로 저장된다.
  - 유효자릿수가 7자리를 넘어가는 경우 값이 잘려서 저장될 수 있다.
- 8바이트 부동소수점 유효자릿수
  - 소수점을 뺀 후 16자리 숫자까지 거의 정상적으로 저장된다.
  - 유효자릿수가 16자리를 넘어가는 경우 값이 잘려서 저장될 수 있다.
- 부동소수점을 저장할 때 정확하게 저장되지 않는 경우
  - 이유
    - IEEE-754 규격에 따라 부동소수점을 2진수로 바꾸다 보면 정확하게 2진수로 딱 떨어지지 않는 경우가 있다. CPU, OS, 컴파일러, JVM의 문제가 아니다. **IEEE-754 방법에 내재되어 있는 문제**다.
  - 해결책: 시스템에서 **필요한 만큼 소수점 이하 자리수를 적당히 잘라 사용한다.**

```java
System.out.println(7 * 0.1);
// 0.7000000000000001
```

## 결론
- 32비트(float) 메모리에 부동소수점을 저장할 때는 유효자릿수 7자리까지는 거의 가능하다. 
- 64비트(double) 메모리에 부동소수점을 저장할 때는 유효자릿수 15자리까지는 거의 가능하다.
- 그래서 32비트 float을 단정도(single-precision)라 부르고,
 64비트는 두 배 정밀하게 값을 저장한다고 해서 배정도(double-precision)이라 부른다.

## 메모리 비트와 2진수
- 메모리의 각 비트는 전기의 on/off 상태를 나타낸다.
- 비트의 on 상태를 1, off 상태를 0으로 표현한다.
- 그래서 메모리의 비트 상태를 표현할 때는 2진수로 나타낸다.

## 메모리에 값을 저장하기
- 메모리는 비트로 되어 있기 때문에 어떤 유형의 값이든 2진수로 변환할 수 있다면 메모리에 저장할 수 있다.
- 예) 빛을 저장하기
 - 카메라 렌즈로 들어온 빛을 메모리에 저장하려면 2진수로 변환해야 한다.
 - 이런 역할을 하는 것이 이미지 센서이다.
- 예) 소리를 저장하기
 - 소리도 마찬가지이다. 메모리에 저장하려면 2진수로 변환해야 한다.
 - 마이크로 들어온 음파를 ADC를 통해 디지털 신호, 즉 2진수로 변환한다.

## 부동소수점이 메모리에 저장되는 원리
- 부동소수점도 메모리에 저장하려면 2진수로 표현할 수 있어야 한다.
- **부동소수점을 2진수로 변환**하는 것을 "**정규화(nomalized)**"라 부른다.
- 이런 정규화 규칙을 정의한 문서가 "IEEE-754"이다.
- 부동소수점을 2진수로 바꿀 때, 가수부와 지수부로 분리하여 변환한다. 
- **가수부는 'Sign-Magnitude 방식'**으로 변환하고, **지수부는 'Excess-K 방식'**으로 변환한다. 

### IEEE-754
- 부동소수점을 32비트와 64비트로 표현하는 방법에 대해 정의하고 있다.
- 32비트로 표현하는 방법을 "single-precision(정밀도 1; 단정도)"이라 한다.
- 64비트로 표현하는 방법은 32비트에 대비해 두 배 가량 더 정밀하게 표현할 수 있다고 해서 "double-precision(정밀도가 두 배; 배정도)"이라 한다.

### 부동소수점을 2진수로 표현하는 방법
- 자바에서 부동소수점의 정규화는 "IEEE 754-1985" 명세에 따른다.
- 메모리 크기와 비트의 구성
  => 32비트 float 타입(32-bit single-precision; 단정도)
    `[부호비트(1)][지수부(8)][가수부(23)]`
  => 64비트 double 타입(64-bit double-precision; 배정도)
    `[부호비트(1)][지수부(11)][가수부(52)]`
- 부호비트(sign bit)
  음수는 1, 양수는 0.
- 지수(exponent)
  **127 bias**를 사용한다. 즉 2의 지수 값에 127을 더한 결과 값을 사용한다.
- 가수(fraction/mantissa)
  **sign-magnitude** 방식으로 저장한다.
  1.xxxx 값에서 소수점 왼쪽에 있는 1을 제외한 나머지 수를 사용한다.
  가수부에 남는 비트가 있다면 0으로 채운다.

### 실수 값을 정규화하는 방법 = 실수 값을 32비트 2진수로 만드는 방법
- 예: 12.375(10진수)

1) 소수점 앞의 정수 값을 2진수로 변환한다.
  12(10진수)
  = 1100(2진수)  

2) 소수점 뒤의 값을 2진수로 변환한다.

- (1) 소수점을 2로 곱하여 나온 결과에서 정수 부분만을 차례대로 표기한다.
- (2) 소수 부분이 0이거나 반복되면 계산을 멈춘다.
- 예: 0.375(10진수)
  0.375 * 2 = 0.75  --> 0
  0.75 * 2  = 1.5   --> 1
  0.5 * 2   = 1.0   --> 1
  => 0.011(2진수)

3) 2진수 바꾼 최종 결과
  12.375(10진수)
  = 12(10진수) + 0.375(10진수)
  = 1100(2진수) + 0.011(2진수)
  = 1100.011(2진수)
  = `1*2^3 + 1*2^2 + 0*2^1 + 0*2^0 + 0*2^-1 + 1*2^-2 + 1*2^-3`
  = `1*8 + 1*4 + 0*2 + 0*1 + 0*0.5 + 1*0.25 + 1*0.125`

4) **정규화** 

- 소수점의 위치를 조정하여 가수부와 지수부를 분리한다.
- IEEE 754 명세는 다음과 같은 형식으로 가수부와 지수부를 나눈다.
  1.x1x2x3x4...x23(2진수) * 2^e
  => 소수점 왼쪽에 **1만 남도록 소수점을 이동**한다.
  => 소수점 왼쪽은 무조건 1이기 때문에 **저장하지 않고 버린다.**
  => 따라서 **소수점 오른쪽 수만 가수부에 놓는다.**
     즉 x1, x2 등은 가수부 1번 비트부터 23번 비트까지를 의미한다.
  => 23번 비트까지 채우지 못하면 나머지 비트는 0으로 채운다.
- **예)**
  1100.011(2진수)
  = 1.100011(2진수) * 2^3
  가수부 => 100011(2진수)
  지수부 => 3 + 127(bias) = 130(10진수) = 10000010(2진수)

5) 32비트로 표현하기
  `[0][10000010][10001100000000000000000]`
  => 0100_0001_0100_0110_0000_0000_0000_0000
  => 0x41460000

주의!
- 유효 자릿수의 부동소수점이라도 **정규화할 때 2진수로 딱 떨어지지 않은 경우**가 있다.
- 예) 2.127
2 => 0010
0.127 => 
0.127 * 2 = 0.254 --> 0
0.254 * 2 = 0.508 --> 0
0.508 * 2 = 1.016 --> 1
0.016 * 2 = 0.032 --> 0
0.032 * 2 = 0.064 --> 0
0.064 * 2 = 0.128 --> 0
0.128 * 2 = 0.256 --> 0
0.256 * 2 = 0.512 --> 0
0.512 * 2 = 1.024 --> 1
0.024 * 2 = 0.048 --> 0
....
이처럼 **2진수로 완벽히 표현할 수 없는 수**가 있다.
**0.00000....1 의 오차**가 있다.
**그래서 부동소수점은 정수와 다르게 정확하게 메모리에 저장되지 않는다.**





## 부동소수점 정규화 과정
1) 소수점 이상 부분을 2진수로 변환

- 12(10진수) => 1100(2진수)

2) 소수점 이하 부분을 2진수로 변환

- .375
- **소수점을 2로 곱하여 나온 결과에서 정수 부분만을 차례대로 표기**한다.
- **소수 부분이 0이거나 반복되면 계산을 멈춘다.**
- 예: 0.375(10진수)
0.375 * 2 = 0.75  --> 0
0.75 * 2  = 1.5   --> 1
0.5 * 2   = 1.0   --> 1
=> 0.011(2진수)

3) 소수점 이상 2진수와 소수점 이하 2진수를 합친다.
=> 12(1100) + .375(0.011) = 1100.011

4) 정규화
=> 소수점 위치를 조정하여 가수부와 지수부를 **분리**한다.
=> 4.1: **소수점 왼쪽에 1이 한개만 남도록 소수점 위치를 이동**한다.
   = `1.100011 * 2**3 = 1100.011`
=> 4.2: 소수점 앞의 1은 무조건 1이기 때문에 **버린다.**
   = `.100011 * 2**3`
=> 4.3: 가수부와 지수부로 분리한다.
- 가수부(23비트)
   - Sign-Magnitude로 표현한다
   - 따라서 음수나 양수나 같은 2진수 값을 갖는다.
   - 예) 100011
- 지수부(8비트)
   - 2의 제곱승 값이다.
   
   - Excess-K 로 표현한다.
   
   - K값은 `2**(8-1) - 1 = 2**7 - 1 = 128 - 1 = 127` 이다.

   - 예) 3(2의 제곱승) + 127(K값; bias) = 130
     예) 130 = 10000010(2진수)


=> 4.4: 32비트 메모리에 담기  
   - `[1:부호비트][8:지수부][23:가수부] = 32비트`
   
   - 예) 0_10000010_10001100000000000000000
      = 01000001_01000110_00000000_00000000
      = 41_46_00_00(16진수)

   - -12.375
   
   - 예) 1_10000010_10001100000000000000000
       = 11000001_01000110_00000000_00000000
       = c1_46_00_00(16진수)

=> 4.5: 64비트 메모리에 담기

- `[1:부호비트][11:지수부][52:가수부] = 64비트`
- 부호비트(1) = 0
- 지수부(11) = 3 + (2**(11-1) - 1) = 3 + (1024 - 1) = 3 + 1023 = 1026
         = 100_0000_0010
- 가수부(52) = 100011
- 예) 0_10000000010_1000110000000000000000000000000000000000000000000000
 = 01000000_00101000_11000000_00000000_00000000_00000000_00000000_00000000
 = 40_28_c0_00_00_00_00_00(16진수)



# 문자 리터럴

- 자바는 문자를 메모리에 저장할 때 Unicode 규칙에 따라 2바이트 코드로 저장한다.
- `println()`: 출력 값으로 문자 코드가 주어지면 해당 코드를 폰트 파일에서 찾아 출력한다. 만약 폰트 파일에 해당 코드의 문자가 없으면 출력하지 못한다.
- **문자 코드(character code)**: 키보드로 직접 입력할 수 없는 문자를 표현할 때는 그 문자에 대해 정해진 값을 지정한다. 코드값 앞에 `\u` 문자를 붙인다. 키보드로 입력 가능한 문자도 문자 코드로 지정할 수 있다. 

```java
System.out.println('A'); //A
System.out.println('가'); //가

System.out.println('\u4eba'); //人
System.out.println('\u0041'); //A
System.out.println('\uac00'); //가
```

- 문자를 메모리에 저장하려면 문자를 2진수로 바꿀 수 있어야 한다. 문자를 2진수로 바꾸는 규칙을 **문자집합(Character Set)**이라 한다.

- 즉, 각 문자를 표현하기 위해 정의된 값을 문자 코드라 부르고, 각 문자에 부여된 문자 코드의 집합을 문자 집합이라고 부른다. 자바가 사용하는 문자 집합은 유니코드이다.

## 문자 집합(character set)

- 문자를 2진수로 바꾸는 규칙

### ASCII(7bit)

- 영어, 대소문자, 숫자, 특수문자 등
- **한글(11172자)은 정의되어 있지 않다.**

```java
//     - 'A' => 100_0001 = 0x41
//     - 'B' => 100_0010 = 0x42
//     - '1' => 011_0001 = 0x31
//     - '2' => 011_0002 = 0x32
```



### ISO-8859-1(8bit)

- ASCII 문자 + 유럽 문자



### EUC-KR (16bit, KSC-5601)

- 한글 2350자에 대한 규칙
- 현대 통용되는 한글 음절 11172자를 모두 표현할 수 없다.

```java
//     - '가' => 10110000_10100001 = 0xb0a1
//     - '각' => 10110000_10100010 = 0xb0a2
```



### Unicode(16bit, ISO 10646)

- 영어, 한글 모두 2바이트로 표현
- 일반적으로 통용되는 **대부분의 국가의 문자**를 담고 있다.
- **자바가 사용하는 문자 집합**

```java
//     - 'A' => 0x0041
//     - 'B' => 0x0042
//     - '1' => 0x0031
//     - '2' => 0x0032
//     - '가' => 0xac00
//     - '각' => 0xac01
```

- **영어를 2바이트로 표현**하기 때문에 비효율적이다.
- **한글은 새로 정의했기 때문에 EUC-KR과 호환되지 않는다.**



### UTF-8

- Unicode에 있는 문자를 규칙에 따가 1 ~ 4 바이트로 변환한다.
- 문자에 따라 바이트 크기가 다르다.
  - ISO-8859-1 (영어, 숫자, 특수문자): 1바이트로 표현한다.
  - 한글: 3바이트로 표현한다.

```java
//- 1110xxxx 10xxxxxx 10xxxxxx
//- '가' => 0xac00(10101100_00000000, Unicode) 
//     => 1110xxxx 10xxxxxx 10xxxxxx (변환규칙)
//     => 11101010 10110000 10000000 (규칙에 값 적용)
//     => 0xEAB080(UTF-8)
```



## 폰트

### Raster 폰트(bitmap 폰트)

- 크기를 늘리면 계단현상 발생
- 폰트를 도트(점) 정보로 저장한다.
- 출력 속도가 빠르다.
- 단순한 그림이나 복잡한 그림의 파일 크기가 같다.
  - 천연색일 경우 각 점을 3바이트로 표현하기 때문이다.



### Vector 폰트 (truetype 폰트)

- 크기를 늘려도 깔끔하게 출력
- **폰트를 명령어**로 저장한다.
- **그릴 때마다 명령어를 실행해야 하기 때문에 출력 속도가 느리다.**
- 그림이 복잡할수록 명령어가 복잡하기 때문에 파일 크기가 커진다.



# 문자의 리터럴 - 문자 집합(character set)
- 자바는 문자를 다룰 때 **2바이트** 값으로 다룬다.
- 즉 각각의 문자는 규칙에 따라 **0 ~ 65535**까지의 값으로 메모리에 저장된다.
- 각 문자를 표현하기 위해 정의된 값을 '문자 코드(character code)'라 부른다.
- 각 문자에 부여된 문자 코드의 집합을 '문자 집합(chararacter set)'이라 부른다.
- 자바가 사용하는 문자 집합은 '유니코드(Unicode)'이다.

## 유니코드
- 전 세계의 **모든 문자를 컴퓨터에서 일관되게 처리할 목적**으로 정의된 산업 표준 규칙이다.
- 유니코드는 **'문자를 2진수로 표현(인코딩; encoding)'할 때, 두 가지 방식(UTF와 UCS)을 사용한다.** 
- 자바는 **메모리에 문자를 저장할 때는 'UCS**(국제 문제 집합)'를 사용하고, **외부로 입출력 할 때는 'UTF**'를 사용한다.

## UCS(Universal Coded Character Set; 국제 문자 집합)
- 'ISO 10646' 표준을 가리키는 이름이다.
- UCS는 110만개 이상의 문자에 대해 코드 값을 정의하고 있다.
- 그 중에서 첫 65536개(0 ~ 65535 까지의 코드)의 문자 코드가 주로 사용된다.
- 이 범위의 유니코드를 'BMP(Basic Multilingual Plane; 기본 다국어 평면)'라 하며 보통 'UCS-2'라 부른다.
 즉 2바이트 범위에서 정의한 유니코드라는 의미다.  
- 자바가 사용하는 유니코드는 바로 이 'UCS-2'라 불리는 범위의 유니코드이다.

## UTF(UCS Transformation Format)
- 문자를 1바이트 코드 값으로 저장하는 기존 시스템에서 UCS를 사용하기 위해 만든 **문자 인코딩 방식**이다.
- UTF-8, UTF-16, UTF-32가 있으며 주로 UTF-8이 사용된다.

## UTF-8
- UCS의 코드 값 중에서 00 ~ 7F(127개)까지 **ASCII에 해당하는 UCS 코드는 그대로 1바이트로 표현**한다.
 따라서 **ASCII를 기본으로 사용하는 시스템의 경우 UTF-8로 인코딩 된 데이터를 특별한 처리없이 그대로 읽고 쓸 수 있다.**
- 그 외의 문자 코드는 규칙에 따라 2바이트 ~ 4바이트까지 변환하여 표현한다.
- UCS의 UTF-8 변환 규칙
 000000 ~ 00007F: 0xxxxxxx
 000080 ~ 0007FF: 110yyyxx 10xxxxxx
 000800 ~ 00FFFF: 1110yyyy 10yyyyxx 10xxxxxx
 100000 ~ 10FFFF: 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx 
- **대부분의 시스템에서 데이터 입출력 할 때 UTF-8**을 사용한다.
- **자바에서도 데이터 입출력할 때 주로 UTF-8**을 사용하고 있다.

## UTF-16
- UCS-2의 코드 값은 그대로 2바이트로 표현한다.
- ASCII 코드도 UCS-2와 동일하게 2바이트로 표현한다.
- 따라서 UCS-2의 코드 값을 표현할 때는 UCS-2와 같다. 
- UCS-2와 다른 점은 **UCS-2의 범위를 벗어나는 문자 코드 값도 표현할 수 있으**며, UCS-2를 벗어나는 유니코드는 **무조건 4바이트로** 변환한다.
- UCS의 UTF-16 변환 규칙
 000000 ~ 00007F: 00000000 0xxxxxxx
 000080 ~ 0007FF: 00000yyy xxxxxxxx
 000800 ~ 00FFFF: yyyyyyyy xxxxxxxx
 100000 ~ 10FFFF: 110110zz zzyyyyyy 110111yy xxxxxxxx 

## UTF-32
- UCS-4의 4바이트 코드 값을 그대로 표현한다.
- **즉 UTF-32는 UCS-4와 같다**.
- 모든 문자를 4바이트 코드 값으로 표현하기 때문에 메모리 낭비가 심하다.

```java
public class Exam0420 {
  public static void main(String[] args) {
    System.out.println(65);          //65
    System.out.println((char)65);    //A
    System.out.println((char)0x41);  //A
    System.out.println((char)0xAC00);//가
    System.out.println((char)0xAC00 + 1);//각
    
    for (int i = 0; i < 26; i++) {
      System.out.print((char)(i + 65) + ",");
    }
    //A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,
  }
}
```


## 정리

문자를 컴퓨터에 저장하는 방법
- **2진수화(인코딩; encoding)** 시켜서 저장한다.

문자를 2진수로 변환하는 규칙
- 문자집합(character set)

> 컴퓨터에서 인코딩은 사람이 인지할 수 있는 형태의 데이터를 약속된 규칙에 의해 컴퓨터가 사용하는 0과 1로 변환하는 과정을 통틀어 일컫는다.

### 1. ASCII (7bit) 

- 미국 국가 표준 협회(ANSI)에서 영어 알파벳, 숫자, 특수 문자 등을 컴퓨터에서 저장할 수 있도록 **7비트 2진수**로 정의한 인코딩 규칙
- A(0x41), B(0x42), a(0x61), b(0x62), 스페이스(0x20), LF(0x0a), CR(0x0d), 
 !(0x21), #(0x23), $(0x24), %(0x25), &(0x26), +(0x2b),
 0(0x30), 1(0x31), =(0x3d), ?(0x3f), @(0x40) 등.

> 윈도우OS에서는 LFCR(2 byte)를 사용해서 줄 바꿈을 표시한다.
>
> macOS, Linux, Unix에서는 LF(1byte)를 사용하여 줄바꿈을 표시한다.



### 2. ISO-8859-1(ISO-latin-1)

- **HTML 문서의 기본 인코딩**이다.
- **ASCII 문자에 유럽 문자까지 포함**하는 국제 표현 문자 인코딩 규칙이다.
- **가장 널리** 쓰이며 대부분의 서유럽 언어를 지원한다. 
 네덜란드어, 노르웨이어, 덴마크어, 독일어, 로만슈어, 스웨덴어 스코틀랜드 게일어, 
 아이슬란드어, 아일랜드어, 에스파냐어, 영어, 이탈리아어, 페로어, 포르투갈어, 
 프랑스어, 핀란드어, 동유럽의 알바니아어, 아프라카의 스와힐리어, 아프리칸스어. 



### 3. EUC-KR(2바이트; 한글 2560자 + 한자 등 포함)

- 국제 표준 한글 문자 집합이다.
- 한글 음절 한 개에 대해 인코딩 규칙을 정의한 **완성형 인코딩 규칙**이다.
- 현재 유통되는 **모든 한글 음절을 표현할 수 없다.**
- 가(0xb0a1), 각(0xb0a2), 똘(0xb6ca)



### 4. 조합형(2바이트; 한글(1) + 초성(5비트) + 중성(5비트) + 종성(5비트))

- **국제 표준이 아니다.**
- 초성: ㄱ(00010), ㄲ(00011), ㄴ(00100), ㄷ(00101), ...
- 중성: ㅏ(00011), ㅐ(00100), ㅑ(00101), ㅒ(00110), ...
- 종성: ㄱ(00010), ㄲ(00011), ㄱㅅ(00100), ㄴ(00101), ... 
- 예) 꺅(1000 1100 1010 0010 = 0x8ca2)



### 5. MS949(=CP949; 2바이트)

- **윈도우 OS의 인코딩** 규칙이다.
- **EUC-KR + 현재 유통되는 한글 음절 추가 = MS949** (11172자 + 한국 전용 한자 + 옛한글 등)
- MS949에 추가된 문자 예: 똠(0x8c63), 똡(0x8c64), 등
- 기존의 EUC-KR에 문자 코드를 추가했기 때문에 **정렬할 때 문제가 발생한다.**
 "똘똠똡똥(b6ca 8c63 8c64 b6cb)" 문자를 정렬한다면,
 코드의 순서에 따라 "똠똡똘똥"으로 나열될 것이다.



### 6. Unicode(2바이트)

- 국제 표준 인코딩 규칙이다.
- **UCS-2**(Universal Coded Character Set)의 경우 영어, 한글 모두 **2바이트**로 인코딩한다.
- MS949의 모든 한글 문자가 포함되어 있다.
- A(0x0041), B(0x0042), +(0x002b), 가(0xac00), 각(0xac01), ...
- **기존의 EUC-KR과 MS949 코드와 호환되지 않는다.**
- **JVM은 내부**에서 문자열을 다룰 때 **UCS-2**를 사용한다.
 즉 영어, 한글 모두 2바이트 유니코드로 다룬다.



### 7. UTF-8(1~4바이트; Unicode Transformation Format)

- **기존 영어권 시스템에서 유니코드 문자를 사용**하기 위해 탄생함.
- 기존 시스템은 ISO-8859-1 규칙에 따라 영어를 1바이트로 다룬다.
 그러나 유니코드는 영어를 2바이트로 다룬다.
- 유니코드를 사용하려면 영어를 2바이트로 다뤄야 하기 때문에 기존 시스템을 모두 변경해야 한다.
- 즉 **기존 시스템을 변경하지 않고 유니코드를 사용할 수 있도록 하기 위해 UTF-8을 만들었다.**

- 한글은(ac00 ~ d7af) 0800 ~ ffff 에 속하기 때문에 **3바이트로 변환**한다.
- UCS-2의 '가(0xac00)'를 UTF-8로 인코딩하기
 '가' => 1010 1100 0000 0000 (UTF-16) 
     => 1110 1010 1011 0000 1000 0000 (UTF-8)
     => 0xEAB080



# 논리값 리터럴

- 4바이트 Int 메모리에 저장한다.

- **배열 값인 경우 1바이트 메모리**에 저장한다. 

- true는 1, false는 0 값이지만 직접 정수를 지정해서는 안 된다. 

- **c언어**의 경우 자바의 true, false 처럼 **논리 값을 표현하는 키워드가 없다.** 





# 문자열 리터럴

- 문자열 리터럴은 자바의 기본 타입이 아니라 객체이다.
- 객체란? **여러 데이터들의 덩어리**이다. 
- 문자열 연결 연산자(concatenation): + 
  - 이때 두 개의 문자열이 연결된 **새 문자열이 생성**된다,
  - 문자열과 **다른 종류의 값을 연결**할 수 있다. 연결되기 전 다른 종류의 값이 **먼저 문자열로 바뀐 다음에 연결**된다.





# 이스케이프 문자(escape character) 

- 이스케이프 문자(문자 제어 코드): 화면에 출력하는 문자가 아니라 문자 출력을 제어하는 문자이다.
- 제어 문자
 \n - Line Feed(LF), 0x0a
 \r - Carrage Return(CR), 0x0d
 \f - Form Feed, 0x0c
 \t - Tab, 0x09
 \b - Backspace, 0x08
 \' - Single Quote, 0x27
 \" - Double Quote, 0x22
 \\ - Backslash, 0x5c