---
title: "✍ 200811_TIL"
categories: TIL
tags: [ TIL ]
---



- 객체지향에서 중요한 것을 클래스를 빨리 파악하는 것이다. 이 클래스가 다른 클래스와 어떤 관계를 맺는지, 어떤 일을 하는지, 그리고 어떤 멤버들이 있는지 파악한다. 문법은 그 다음이다.

- 메인 메서드는 프로그램의 진입점(entry point)이다. 따라서 메인 메서드의 접근자는 항상 public이어야 한다. 메인 메서드가 없으면 프로그램을 시작할 수 없다. 



## CRUD

대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능 4가지를 묶어서 일컫는 말이다. 이러한 4개 조작을 모두 할 수 없다면 그 소프트웨어는 완전하다고 할 수 없다. 

| 이름           | 조작 | SQL    |
| -------------- | ---- | ------ |
| Create         | 생성 | INSERT |
| Read(Retrieve) | 읽기 | SELECT |
| Update         | 갱신 | UPDATE |
| Delete         | 삭제 | DELETE |



## 오버로드(Overloading)

- 추가로 적재한다. 
- 생성자가 있는데, 클래스를 사용하는 개발자에게.. 또 다른 선택권을 위해서..

```java
public Car() {}

public Car(String model, String maker, int capacity) {
	this.model = model;
	this.maker = maker;
	this.capacity = capacity;
}
```



## 기능 추가 방법

### 1. 기존의 클래스를 변경한다.

기존 클래스의 소스코드를 손댈 경우 기존 클래스를 사용하여 만든 프로그램들도 영향을 받는다. 때에 따라 심각한 오류가 발생할 수도 있다. 또한 

### 2. 기존 클래스를 복사하여 새 클래스를 만든다.

![before-inheritance2](https://user-images.githubusercontent.com/50407047/89854788-c3eca300-dbcf-11ea-9943-df3f64d7fac4.jpg)

### 3. 상속한다.



### 상속 이전 기능 추가

1. 기존의 클래스 변경(기존 코드를 손댄다)
   - 기존 프로그램 영향받음 
   - 기능 추가하는 것 정도는 괜찮지만... 
   - 기존 기능을 변경하면 기존 프로그램 심각한 영향
   - 기존 코드 손대는 것은 매우 위험하다.
   - 계속 코드 덧붙이면 **누더기 코드**가 될 가능성이 있다. 
2. 기존 코드를 복사하여 새 클래스를 만든다.
   - 같은 일을 하는 클래스가 여러개 존재하면 관리하기 힘들다
   - 원본에 버그가 있으면 버그도 복사함. 



자바

- deprecated: 이전 버전이라도 계속 지원
- 계속 기능을 추가하면서 버리지 않아서 아주 지저분해짐

파이썬: 문법이 달라짐: 과거 호환이 안됨.



data accecc : 디에요???? 

끄집어 낼 것.

작업 데이터를 다루는 클래스 ->



상속: xㅏㅁㄴ 수정하면 버그가 다 수저됨. 

1. 원래 소스를 손댄다 -> 기존의 잘 되는 것도 안 될 수 있음
2. 그대로 복사해서 기능을 추가한다 -> 이런 경우가 계속되면 원본에 있는 기능에 문제가 있으면 전체를 다 바꿔야 하기 때문에 유지보수가 힘듦



- 
  





## 클래스 로딩 과정

자바의 모든 클래스는 자바 오브젝트의 자손임(sub class)

- 클래스로딩
  - 클래스 찾기
    - 과정 찾아 넣기
  - 검증
  - 로딩
  - static 변수 생성
  - static 블럭 실행
  - 프로그램 엔트리 포인트인 main() 호출



### 인스턴스 생성 절차

1. 서브클래스가 사용한다고 선언한 수퍼클래스를 먼저 메모리에 로딩한다.
2. 서브클래스를 메모리에 로딩한다.
3. 수퍼클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.
4. 서브클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.

   
    // 1) B 클래스가 사용한다고 선언한 클래스를 먼저 메모리에 로딩한다.
    //    즉 A 클래스를 메모리에 로딩한다.
    // 2) B 클래스를 메모리에 로딩한다.
    // 3) A 클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다.
    // 4) B 클래스에 선언된 대로 인스턴스 변수를 Heap에 만든다. 
    
    // 그래서 인스턴스를 생성할 때는 항상 상속 받아야 하는 클래스 파일이 모두 있어야 한다.
    // 테스트 하는 방법?
    // => A.class 파일을 제거하고 Exam01을 실행해 보라! 




## 상속

### 상속이란?
기존에 만든 클래스를 자신의 코드처럼 사용하는 기법이다. 보통 기존 코드를 손대지 않고 새 코드를 덧붙일 때 많이 사용한다. 상속해주는 클래스는 수퍼클래스(super class), 부모클래스(parents class)라고 한다. 다른 클래스를 상속 받는 클래스는 서브클래스(sub class), 자식클래스(child class)라고 한다.

### 오해하지 말자
상속은 기존 코드를 그대로 가져오는 자동복사 개념이 아니다. 자동복사 개념이라면 실제 수퍼클래스.class 파일은 필요하지 않을 것이다. 그러나 수퍼클래스.class 파일을 삭제하면 `java.lang.NoClassDefFoundError`가 뜬다. 즉, 상속받은 클래스가 없으면 실행 자체가 되지 않는다는 말이다. 상속은 **내가(서브클래스) 쟤를(수퍼클래스) 쓰겠다는 선언**이다!


## java.lang.Object
상속 안 한다고 적으면 무조건 java.lang.Object 상속된다.
> Class `Object` is the root of the class hierarchy. Every class has `Object` as a superclass. All objects, including arrays, implement the methods of this class.

- `toString()`
- `equals()`
- `hashCode()`
- `getClass()`: 어느 클래스에서 사용되니?
- `clone()`: 인스턴스 복제
- `finalize()`
  - 가비지 컬렉터가 인스턴스를 제거하기전에 바로 호출 
  - c++의 (distructor())
  - 자바에서는 호출된다는 보장이 없음
  - 메모리가 충분하면 
  - 어차피 프로그램 종료되면 다 해제되니까 종료 될 때까지 가비지 컬렉터 실행 안 될 수도 있음

자바의 모든 클래스는 이 메서드들을 다 갖고 있다. 즉 모든 클래스의 최고 조상은 Object이기 때문이다.자바의 모든 객체는 이 메서드들을 호출할 수 있다.

수퍼 클래스의 기본 생성자를 호출 

호출은 거꾸로 가서 



ex05 -g

수퍼스클래스 

어던 생성자를 호출하면 수퍼클래스의 기본  생성자를 호출한다.

바꾸고 싶으면 명시해야 함.



## 단일상속

두개의 클래스를 부모로 가질 수 있다면?????????

- C++에서는 가능했음 
- 그러나 각 부모에서 같은 이름의 메서드를 가질 때 뭘 호출해야 할 지 모른다..
- bjarne stroustrup(c++창시자): 다중상속에 확실히 문제가 있다! 괜히 집어넣었다!
- 그래서 Java에서는 막음
- 인터페이스는 다중 상속 허용. 클래스 세계에서는 다중 상속 허용 안함